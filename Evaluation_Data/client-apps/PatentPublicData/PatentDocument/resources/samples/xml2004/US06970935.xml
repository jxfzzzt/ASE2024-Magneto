<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE us-patent-grant SYSTEM "us-patent-grant-v40-2004-12-02.dtd" [ ]>
<us-patent-grant lang="EN" dtd-version="v40 2004-12-02" file="US06970935-20051129.XML" status="PRODUCTION" id="us-patent-grant" country="US" date-produced="20051114" date-publ="20051129">
<us-bibliographic-data-grant>
<publication-reference>
<document-id>
<country>US</country>
<doc-number>06970935</doc-number>
<kind>B1</kind>
<date>20051129</date>
</document-id>
</publication-reference>
<application-reference appl-type="utility">
<document-id>
<country>US</country>
<doc-number>09703574</doc-number>
<date>20001101</date>
</document-id>
</application-reference>
<us-application-series-code>09</us-application-series-code>
<us-term-of-grant>
<us-term-extension>730</us-term-extension>
</us-term-of-grant>
<classification-ipc>
<edition>7</edition>
<main-classification>G06F015/16</main-classification>
</classification-ipc>
<classification-national>
<country>US</country>
<main-classification>709230</main-classification>
<further-classification>709228</further-classification>
<further-classification>370356</further-classification>
<further-classification>379 8802</further-classification>
</classification-national>
<invention-title id="d0e53">Conversational networking via transport, coding and control conversational protocols</invention-title>
<references-cited>
<citation>
<patcit num="00001">
<document-id>
<country>US</country>
<doc-number>5918020</doc-number>
<kind>A</kind>
<name>Blackard et al.</name>
<date>19990600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709228</main-classification></classification-national>
</citation>
<citation>
<patcit num="00002">
<document-id>
<country>US</country>
<doc-number>5995096</doc-number>
<kind>A</kind>
<name>Kitahara et al.</name>
<date>19991100</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>345753</main-classification></classification-national>
</citation>
<citation>
<patcit num="00003">
<document-id>
<country>US</country>
<doc-number>6195636</doc-number>
<kind>B1</kind>
<name>Crupi et al.</name>
<date>20010200</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>704231</main-classification></classification-national>
</citation>
<citation>
<patcit num="00004">
<document-id>
<country>US</country>
<doc-number>6233235</doc-number>
<kind>B1</kind>
<name>Burke et al.</name>
<date>20010500</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370356</main-classification></classification-national>
</citation>
<citation>
<patcit num="00005">
<document-id>
<country>US</country>
<doc-number>6289085</doc-number>
<kind>B1</kind>
<name>Miyashita et al.</name>
<date>20010900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>379 8802</main-classification></classification-national>
</citation>
<citation>
<patcit num="00006">
<document-id>
<country>US</country>
<doc-number>6289382</doc-number>
<kind>B1</kind>
<name>Bowman-Amuah</name>
<date>20010900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709226</main-classification></classification-national>
</citation>
<citation>
<patcit num="00007">
<document-id>
<country>US</country>
<doc-number>6304574</doc-number>
<kind>B1</kind>
<name>Schoo et al.</name>
<date>20011000</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370401</main-classification></classification-national>
</citation>
<citation>
<patcit num="00008">
<document-id>
<country>US</country>
<doc-number>6574213</doc-number>
<kind>B1</kind>
<name>Anandakumar et al.</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370349</main-classification></classification-national>
</citation>
<citation>
<patcit num="00009">
<document-id>
<country>US</country>
<doc-number>6580695</doc-number>
<kind>B2</kind>
<name>Kluck et al.</name>
<date>20030600</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>370261</main-classification></classification-national>
</citation>
<citation>
<patcit num="00010">
<document-id>
<country>US</country>
<doc-number>2002/0120760</doc-number>
<kind>A1</kind>
<name>Kimchi et al.</name>
<date>20020800</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>709230</main-classification></classification-national>
</citation>
<citation>
<patcit num="00011">
<document-id>
<country>US</country>
<doc-number>2003/0177354</doc-number>
<kind>A1</kind>
<name>Carter</name>
<date>20030900</date>
</document-id>
</patcit>
<category>cited by examiner</category>
<classification-national><country>US</country><main-classification>713164</main-classification></classification-national>
</citation>
</references-cited>
<number-of-claims>30</number-of-claims>
<us-exemplary-claim>1</us-exemplary-claim>
<field-of-search>
<classification-national>
<country>US</country>
<main-classification>709230</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>709228</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370261</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370356</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370349</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>370401</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>379 8802</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>345753</main-classification>
</classification-national>
<classification-national>
<country>US</country>
<main-classification>713164</main-classification>
</classification-national>
</field-of-search>
<figures>
<number-of-drawing-sheets>18</number-of-drawing-sheets>
<number-of-figures>21</number-of-figures>
</figures>
<parties>
<applicants>
<applicant sequence="001" app-type="applicant-inventor" designation="us-only">
<addressbook>
<last-name>Maes</last-name>
<first-name>Stephane H.</first-name>
<address>
<city>Danbury</city>
<state>CT</state>
<country>US</country>
</address>
</addressbook>
<nationality>
<country>omitted</country>
</nationality>
<residence>
<country>US</country>
</residence>
</applicant>
</applicants>
<agents>
<agent sequence="01" rep-type="attorney">
<addressbook>
<orgname>F.Chau &#x26; Associates, LLC</orgname>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
<agent sequence="02" rep-type="attorney">
<addressbook>
<last-name>DeRosa</last-name>
<first-name>Frank V.</first-name>
<address>
<country>unknown</country>
</address>
</addressbook>
</agent>
</agents>
</parties>
<assignees>
<assignee>
<addressbook>
<orgname>International Business Machines Corporation</orgname>
<role>02</role>
<address>
<city>Armonk</city>
<state>NY</state>
<country>US</country>
</address>
</addressbook>
</assignee>
</assignees>
<examiners>
<primary-examiner>
<last-name>Lin</last-name>
<first-name>Wen-Tai</first-name>
<department>2154</department>
</primary-examiner>
</examiners>
</us-bibliographic-data-grant>
<abstract id="abstract">
<p id="p-0001" num="0000">Conversational protocols for implementing distributed conversational networking architectures and/or distributed conversational applications, as well as real-time conversational computing between network-connected pervasive computing devices and/or servers over a computer network. In one aspect of the invention, a communication stack for use in a real-time distributed conversational network comprises a first layer for generating encoded audio data, a second layer for wrapping encoded audio data in a real-time encoded audio data stream, and a third layer for wrapping control messages in a real-time control data stream for real-time control of conversational distributed functions over the network. Preferably, the communication stack comprises extensions of RTP (Real Time Protocol) and RTCP (Real Time Control Protocol) to respectively transmit, in real-time, the necessary encoded audio data and control data for executing and controlling distributed conversational functions, wherein meta information associated with the real-time encoded audio stream is added as an extension of header of an RTP packet, and wherein meta information associated with the real-time control data stream is added as an extension of a header of an packet.</p>
</abstract>
<drawings id="DRAWINGS">
<figure id="Fig-EMI-D00000" num="00000">
<img id="EMI-D00000" he="168.32mm" wi="246.04mm" file="US06970935-20051129-D00000.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00001" num="00001">
<img id="EMI-D00001" he="247.06mm" wi="175.09mm" file="US06970935-20051129-D00001.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00002" num="00002">
<img id="EMI-D00002" he="251.63mm" wi="173.99mm" file="US06970935-20051129-D00002.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00003" num="00003">
<img id="EMI-D00003" he="195.24mm" wi="189.40mm" file="US06970935-20051129-D00003.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00004" num="00004">
<img id="EMI-D00004" he="246.63mm" wi="199.05mm" file="US06970935-20051129-D00004.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00005" num="00005">
<img id="EMI-D00005" he="236.98mm" wi="137.24mm" file="US06970935-20051129-D00005.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00006" num="00006">
<img id="EMI-D00006" he="210.31mm" wi="189.82mm" file="US06970935-20051129-D00006.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00007" num="00007">
<img id="EMI-D00007" he="248.92mm" wi="146.90mm" file="US06970935-20051129-D00007.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00008" num="00008">
<img id="EMI-D00008" he="221.57mm" wi="132.25mm" file="US06970935-20051129-D00008.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00009" num="00009">
<img id="EMI-D00009" he="223.86mm" wi="178.22mm" file="US06970935-20051129-D00009.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00010" num="00010">
<img id="EMI-D00010" he="240.45mm" wi="152.74mm" file="US06970935-20051129-D00010.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00011" num="00011">
<img id="EMI-D00011" he="221.91mm" wi="138.01mm" file="US06970935-20051129-D00011.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00012" num="00012">
<img id="EMI-D00012" he="237.32mm" wi="185.93mm" file="US06970935-20051129-D00012.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00013" num="00013">
<img id="EMI-D00013" he="252.05mm" wi="180.17mm" file="US06970935-20051129-D00013.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00014" num="00014">
<img id="EMI-D00014" he="236.22mm" wi="183.98mm" file="US06970935-20051129-D00014.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00015" num="00015">
<img id="EMI-D00015" he="225.38mm" wi="152.74mm" file="US06970935-20051129-D00015.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00016" num="00016">
<img id="EMI-D00016" he="241.22mm" wi="188.64mm" file="US06970935-20051129-D00016.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00017" num="00017">
<img id="EMI-D00017" he="240.03mm" wi="153.16mm" file="US06970935-20051129-D00017.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
<figure id="Fig-EMI-D00018" num="00018">
<img id="EMI-D00018" he="237.74mm" wi="187.54mm" file="US06970935-20051129-D00018.TIF" alt="embedded image" img-content="drawing" img-format="tif"/>
</figure>
</drawings>
<description id="description">
<?BRFSUM description="Brief Summary" end="lead"?>
<heading id="h-0001" level="1">BACKGROUND</heading>
<p id="p-0002" num="0001">1. Technical Field</p>
<p id="p-0003" num="0002">The present application relates generally to systems and method for providing conversational networking and, more particularly, to conversational protocols for implementing distributed conversational applications over a computer network.</p>
<p id="p-0004" num="0003">2. Description of Related Art</p>
<p id="p-0005" num="0004">The computing world is evolving towards an era where billions of interconnected pervasive clients communicate with powerful information servers. Indeed, this millennium will be characterized by the availability of multiple information devices that make ubiquitous information access an accepted fact of life. The evolution of the computer world towards billions of pervasive devices interconnected via the Internet, wireless networks or spontaneous networks (such as Bluetooth and Jini) will revolutionize the principles underlying man-machine interaction. In the near future, personal information devices will offer ubiquitous access, bringing with them the ability to create, manipulate and exchange any information anywhere and anytime using interaction modalities (e.g., speech and/or GUI) most suited to the user's current needs and abilities. Such devices will include familiar access devices such as conventional telephones, cell phones, smart phones, pocket organizers, PDAs and PCs, which vary widely in the interface peripherals they use to communicate with the user.</p>
<p id="p-0006" num="0005">The information being manipulated via such devices may reside on the local device or be accessed from a remote server via a communications network using open, interoperable protocols and standards. The implementation of such open standards also leads to a seamless integration across multiple networks and multiple information sources such as an individual's personal information, corporate information available on private networks, and public information accessible via the global Internet. The availability of a unified information source will define productivity applications and tools of the future. Indeed, users will increasingly interact with electronic information, as opposed to interacting with platform-specific software applications as is currently done in the world of the desktop PC.</p>
<p id="p-0007" num="0006">With the pervasiveness of computing causing information appliances to merge into the users environment, the user's mental model of these devices is likely to undergo a dramatic shift. Today, users regard computing as an activity that is performed at a single device like the PC. As information appliances abound, user interaction with these multiple devices will be grounded on a different set of abstractions. The most intuitive and effective user model for such interaction will be based on what users are already familiar with in today's world of human-intermediated information interchange, where information transactions are modeled as a conversation amongst the various participants in the conversation.</p>
<p id="p-0008" num="0007">Indeed, it is expected that information-centric computing carried out over a plethora of multi-modal information devices will be essentially conversational in nature and will foster an explosion of conversational devices and applications. It is to be noted that the term &#x201c;conversational&#x201d; is used to mean more than speech interaction&#x2014;it encompasses all forms of information interchange, where such interchange is typically embodied by one participant posing a request that is fulfilled by one or more participants in the conversational interaction. The core principle behind the conversational interaction is that any interaction between the user and the machine be handled as a dialog similar to human&#x2014;human dialog. Accordingly, the increasing availability of information available over a communications network, along with the rise in the computational power available to each user to manipulate this information, brings with it a concomitant need to increase the bandwidth of man-machine communication so that the increased human-machine interaction that will result from the pervasive use of such information devices will be as natural and simple as if the user was having a conversation with another individual.</p>
<p id="p-0009" num="0008">With the increased deployment of conversational systems, however, new technical challenges and limitations must be addressed. For instance, currently available pervasive clients typically do not have the required memory and/or processing power to support complex conversational tasks such as recognition and presentation. Indeed, even with the rapid evolution of the embedded processor capabilities (low power or regular processors), one can not expect that all the processing power or memory is available for executing complex conversational tasks such as, for example, speech recognition (especially when the vocabulary size is large or specialized or when domain-specific/application-specific language models or grammars are needed), NLU (natural language understanding), NLG (natural language generation), TTS(text-to-speech synthesis), audio capture and compression/decompression, playback, dialog generation, dialog management, speaker recognition, topic recognition, and audio/multimedia indexing and searching, etc.</p>
<p id="p-0010" num="0009">Moreover, even if a networked device is &#x201c;powerful&#x201d; enough (in terms of CPU and memory) to execute all these conversational tasks, the device may not have access to the appropriate domain-specific and application-specific data files or appropriate algorithms (e.g., engines) to adequately execute such tasks. Indeed, vendors and service providers typically do not allow for open exchange of the algorithms (conversational engines) for executing conversational tasks and/or the data files (conversational arguments) utilized by such algorithms (e.g., grammars, language models, vocabulary files, parsing, tags, voiceprints, TTS rules, etc.) to execute such tasks, which they consider intellectual, business logic and technology crown jewels. Indeed, some conversational functions may be too specific to a given service, thereby requiring back end information that is only available from other devices or machines on the network.</p>
<p id="p-0011" num="0010">Furthermore, the network infrastructure may not provide adequate bandwidth for rapidly exchanging data files needed by conversational engines for executing conversational tasks. For example, NLU and NLG services on a client device typically require server-side assistance since the complete set of conversational arguments or functions needed to generate the dialog (e.g., parser, tagger, translator, etc.) may be too extensive (in terms of communication bandwidth) for transmission from the server to the client over the network connection. In addition, even if such data files can be transmitted over the network, such transmission may introduce long delays before the client device is able to commence an application or process an input, thereby preventing real-time interactions.</p>
<p id="p-0012" num="0011">These problems may be solved through implementation of distributed architectures, assuming that such architectures are implemented in appropriately managed networks to guarantee quality of service for each active dialog. Indeed, the problems associated with a distributed architecture and distributed processing between client and servers require new methods for conversational networking. Such methods comprise management of traffic and resources distributed across the network to guarantee appropriate dialog flow of for each user engaged in a conversational interaction across the network.</p>
<p id="p-0013" num="0012">Accordingly, systems and methods that provide conversational networking through implementation of, e.g., distributed speech recognition (DSR), distributed conversational architectures and conversational protocols for transport, coding and control, are highly desirable. Indeed, it would be advantageous to allow network devices with limited resources to perform complex conversational tasks (preferably in real-time) using networked resources in a manner which is automatic and transparent to the users of such devices.</p>
<heading id="h-0002" level="1">SUMMARY OF THE INVENTION</heading>
<p id="p-0014" num="0013">The present invention is directed to conversational protocols for implementing distributed conversational networking architectures and/or distributed conversational applications, as well as real-time conversational computing between network-connected pervasive computing devices and/or servers over a computer network. The implementation of distributed conversational systems/applications according to the present invention is based, in part, on a suitably defined conversational coding, transport and control protocols.</p>
<p id="p-0015" num="0014">In one aspect of the invention, a communication stack for use in a real-time distributed conversational network comprises a first layer for generating encoded audio data, a second layer for wrapping encoded audio data in a real-time encoded audio data stream, and a third layer for wrapping control messages in a real-time control data stream for real-time control of conversational distributed functions over the network.</p>
<p id="p-0016" num="0015">Preferably, the communication stack comprises extensions of RTP (Real Time Protocol) and RTCP (Real Time Control Protocol) to respectively transmit, in real-time, the necessary encoded audio data and control data for executing and controlling distributed conversational functions. Meta information associated with the real-time encoded audio stream is added as an extension of a header of an RTP packet, wherein the RTP header extension comprises one field indicating an encoding type of the encoded audio data in the RTP packet and a second field comprising header information associated with a file of the encoded audio data. Further, meta information associated with the real-time control data stream is added as an extension of a header of an RTCP (Real Time Control Protocol) packet, wherein the RTCP header extension comprises a first field indicating a type of conversational distributed protocol and a second field comprising a corresponding control message. The control data may comprise any type of application-specific control data that may be utilized for implementing a specific distributed framework.</p>
<p id="p-0017" num="0016">In another aspect, the communication stack comprises a fourth layer for generating a real-time transmission control data stream, wherein the real-time transmission control data stream comprises meta information for providing coding scheme notifications. Meta information associated with the real-time transmission control data stream is preferably added as an extension of a header of an RTCP (Real Time Control Protocol) packet.</p>
<p id="p-0018" num="0017">These and other aspects, features and advantages of the present invention will be described and become apparent from the following detailed description of preferred embodiments, which is to be read in connection with the accompanying drawings.</p>
<?BRFSUM description="Brief Summary" end="tail"?>
<?brief-description-of-drawings description="Brief Description of Drawings" end="lead"?>
<description-of-drawings>
<heading id="h-0003" level="1">BRIEF DESCRIPTION OF THE DRAWINGS</heading>
<p id="p-0019" num="0018"><figref idref="DRAWINGS">FIG. 1</figref> is a diagram illustrating conversational protocols that may be utilized to support conversational computing according to one aspect of the present invention;</p>
<p id="p-0020" num="0019"><figref idref="DRAWINGS">FIGS. 2</figref><i>a </i>and <b>2</b><i>b </i>comprise a diagram of a system/method for encoding/decoding (CODEC) audio data according to an embodiment of the present invention;</p>
<p id="p-0021" num="0020"><figref idref="DRAWINGS">FIG. 3</figref> is a diagram illustrating a file format for encoded audio data according to one aspect of the present invention;</p>
<p id="p-0022" num="0021"><figref idref="DRAWINGS">FIG. 4</figref> is a diagram illustrating a format of a file header of the encoded audio file of <figref idref="DRAWINGS">FIG. 3</figref>, according to one aspect of the present invention;</p>
<p id="p-0023" num="0022"><figref idref="DRAWINGS">FIG. 5</figref> is a diagram further illustrating a format of the file header of <figref idref="DRAWINGS">FIG. 4</figref> according to one aspect of the present invention;</p>
<p id="p-0024" num="0023"><figref idref="DRAWINGS">FIG. 6</figref> is a diagram further illustrating a format of the file header of <figref idref="DRAWINGS">FIG. 4</figref> according to one aspect of the present invention;</p>
<p id="p-0025" num="0024"><figref idref="DRAWINGS">FIG. 7</figref> is a diagram illustrating a conventional format for RTP (Real Time Protocol);</p>
<p id="p-0026" num="0025"><figref idref="DRAWINGS">FIG. 8</figref> is a diagram illustrating a method for extending the header of RTP to produce RTCCP (Real Time Conversational Coding Protocol) according to one aspect of the present invention;</p>
<p id="p-0027" num="0026"><figref idref="DRAWINGS">FIG. 9</figref> is a diagram of a system/method for generating an RTCCP data stream according to an embodiment of the present invention;</p>
<p id="p-0028" num="0027"><figref idref="DRAWINGS">FIG. 10</figref> is a diagram of a method for generating an RTCCP data stream according to one aspect of the present invention;</p>
<p id="p-0029" num="0028"><figref idref="DRAWINGS">FIG. 11</figref> is a diagram illustrating conversational protocols according to one aspect of the present invention that are implemented for network communication between a source and a receiver;</p>
<p id="p-0030" num="0029"><figref idref="DRAWINGS">FIG. 12</figref> is a diagram illustrating a method for implementing RTCDP (real time conversational distributed protocol) on top of RTCP according to one aspect of the present invention;</p>
<p id="p-0031" num="0030"><figref idref="DRAWINGS">FIG. 13</figref> is a diagram illustrating conversational protocols according to another aspect of the present invention that are implemented for network communication between a source and a receiver;</p>
<p id="p-0032" num="0031"><figref idref="DRAWINGS">FIG. 14</figref><i>a </i>is a diagram illustrating a system/method for implementing a distributed conversational framework using proxy servers according to one aspect of the present invention;</p>
<p id="p-0033" num="0032"><figref idref="DRAWINGS">FIG. 14</figref><i>b </i>is a diagram illustrating a system/method for implementing a distributed conversational framework using proxy servers according to another aspect of the present invention;</p>
<p id="p-0034" num="0033"><figref idref="DRAWINGS">FIG. 15</figref> is a diagram illustrating a conversational protocol stack according to one aspect of the present invention;</p>
<p id="p-0035" num="0034"><figref idref="DRAWINGS">FIG. 16</figref> is a diagram illustrating a system/method for implementing a real-time distributed protocol using RTSP (real time streaming protocol) according to another aspect of the present invention;</p>
<p id="p-0036" num="0035"><figref idref="DRAWINGS">FIG. 17</figref> is a diagram illustrating an exemplary distributed conversational network architecture that may be implemented using conversational protocols according to the present invention;</p>
<p id="p-0037" num="0036"><figref idref="DRAWINGS">FIG. 18</figref> is a diagram illustrating another exemplary distributed conversational networking architecture that may be implemented using conversational protocols according to the present invention; and</p>
<p id="p-0038" num="0037"><figref idref="DRAWINGS">FIG. 19</figref> is a diagram illustrating another exemplary distributed conversational networking architecture that may be implemented using conversational protocols according to the present invention.</p>
</description-of-drawings>
<?brief-description-of-drawings description="Brief Description of Drawings" end="tail"?>
<?DETDESC description="Detailed Description" end="lead"?>
<heading id="h-0004" level="1">DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS</heading>
<p id="p-0039" num="0038">The present invention may be implemented in various forms of hardware, software, firmware, special purpose processors, or a combination thereof. Preferably, the invention is implemented in software as an application comprising program instructions that are tangibly embodied on one or more program storage devices (e.g., magnetic floppy disk, RAM, CD ROM, ROM and Flash memory) and executable by any device, machine or platform comprising suitable architecture. Since the invention is preferably implemented in software, the system architectures and method steps may differ depending upon the manner in which the invention is programmed. Given the teachings herein, one of ordinary skill in the related art will be able to contemplate these and similar implementations or configurations.</p>
<p id="h-0005" num="0000">I. Overview</p>
<p id="p-0040" num="0039">The present invention is directed to conversational protocols for implementing distributed conversational networking architectures and/or distributed conversational applications, as well as real-time conversational computing between network-connected pervasive computing devices and/or servers over a computer network. More specifically, the implementation of distributed conversational systems/applications according to the present invention is based in part on a suitably defined conversational coding, transport and control protocols.</p>
<p id="p-0041" num="0040">There are three basic configurations for implementing conversational protocols in accordance with the present invention and the format of such conversational protocols will vary based on the underlying transport layers and desired application. In a preferred embodiment, conversational protocols for providing distributed conversational networking are implemented on top of RTP (Real Time Protocol). For example, as described in detail below, a conversational coding protocol according to one aspect of the present invention is implemented by extending RTP to produce what is referred to herein as RTCCP (real time conversational coding protocol).</p>
<p id="p-0042" num="0041">As is known in the art, the real time protocol is a method for providing real time transmission of data over a network. RTP does not have all the functions of a transport protocol and is typically used on top of a network level protocol such as TCP (transmission control protocol) or UDP (User Datagram Protocol). TCP is known as a transport level protocol which controls the transmission and the flow of data between two hosts on a network. The TCP protocol may not be ideal in real-time implementations due to its data flow control and reliability mechanisms which can halt/interrupt the flow of data transmission over a network. More specifically, TCP provides reliability through a mechanism that ensures that every single datagram (or packet) is delivered. This mechanism involves assigning each datagram a sequence number and sequentially transmitting each datagram to a receiver. For a given transmitted datagram, if the receiver successfully receives the datagram (i.e., receives an undamaged datagram), the receiver will transmit an acknowledgment message (ACK) to inform the source that it has successfully received the datagram and to send the next sequential datagram. If, after transmitting a given datagram, the source does not receive an ACK message for the datagram, the source will continue to transmit the datagram until an ACK message is returned. Consequently, the flow of datagrams may be temporarily interrupted during transmission as the receiver waits for an undamaged datagram.</p>
<p id="p-0043" num="0042">UDP is alternative protocol to TCP for use with RTP. The UDP does not utilize the reliability and flow control mechanisms of TCP but rather transmits the datagrams to the receiver in a continuous stream. Consequently, UDP is a preferred protocol for use with RTP for real-time implementations since it delivers a constant stream of datagrams without any significant delay (other than connection bandwidth and network congestion). Despite its lack of a reliably delivery mechanism, the implementation of conversational protocols on top of RTP using UDP in accordance with the present invention preferably employs a reliable delivery mechanism (usually at a relatively low bit rate) similar to TCP/IP, but not as restrictive as TCP. Indeed, as described in detail below, in the absence of TCP/IP, reliable packet delivery is emulated by providing a packet delivery confirmation and re-sending mechanism. Advantageously, the implementation of conversational protocols on top of RTP and UDP (with a reliability mechanism) affords real-time interaction when needed (e.g., when immediate user recognition is expected by the dialog or when the input must directly impact the state of the dialog). The present invention will provide a detailed embodiment of implementing conversational protocols using real time protocols.</p>
<p id="p-0044" num="0043">It is to be understood that the conversational protocols described herein may be implemented as extensions to other transport mechanisms. For instance, the conversational protocols may be implemented on top of TCP/IP. This presents the advantage to be the most common type of transport protocol that is employed&#x2014;It is the Internet transport protocol. While TCP/IP is the simplest default mechanism to transport data and control from one device to another using, e.g., FTP (file transfer protocol), RMI (remote method invocation), RPC (remote procedure call), etc., as explained above, it does not guarantee real-time interaction. Indeed, missing or damages packets are systematically waited for or re-sent. This may not be an issue for, e.g., deferred recognition tasks. For example, a form filling process in VoiceXML (http://www.voicexml.com), may not expect immediate speech recognition for each field that is filled, but only recognition upon submission of the entire form to the server. In any event, it is to be understood that a preferred embodiment of implementing RTP-based conversational protocols may utilize TCP/IP if the given application calls for guaranteed, but non-real time, transmission of the associated data packets.</p>
<p id="p-0045" num="0044">In another aspect of the present invention, the conversational protocols may be implemented on top of HTTP (hypertext transfer protocol) (or WAP (wireless application protocol). HTTP is the main protocol used on the Internet for hypertext transfer (Web programming model), i.e., transferring data on the World Wide Web. The implementation of conversational protocols on top of HTTP allows direct integration of the engine distribution within browser solutions (e.g. http://www.voiceXML.com) with no major change required in the infrastructure. WAP is an equivalent lightweight transport protocol to use on wireless networks (devices with limited wireless bandwidth connections and limited GUI capabilities). Since HTTP is implemented on TCP/IP and has a significant amount of overhead associated therewith (e.g., most of the remote commands result in multiple exchanges various headers) and because WAP provides a reliable delivery mechanism, the implementation of RTP-based conversational protocols on top of HTTP and WAP is preferable for non-real time applications.</p>
<p id="p-0046" num="0045">It is to be appreciated that the RTP mechanism is preferred when real-time interactions are required. Regardless of the implementation choice, however, the following design principles (definitions) are preferably considered herein for implementing a distributed network using conversational protocols according to the present invention. Conversational protocols according to one aspect of the present invention are preferably defined based on the following criteria:
<ul id="ul0001" list-style="none">
    <li id="ul0001-0001" num="0000">
    <ul id="ul0002" list-style="none">
        <li id="ul0002-0001" num="0046">A suitable audio coding/decoding (Codec) protocol that provides, e.g., minimal distortion of acoustic front-end features and allows reconstruction of intelligible waveforms from compressed feature vectors of speech;</li>
        <li id="ul0002-0002" num="0047">Definition of a file format associated with the encoded audio data;</li>
        <li id="ul0002-0003" num="0048">Definition of a mechanism to select a coding scheme when multiple coding variations are available;</li>
        <li id="ul0002-0004" num="0049">Definition of a streaming mechanism for transmitting the encoded data over a network;</li>
        <li id="ul0002-0005" num="0050">Definition of a mechanism to switch the coding scheme during a stream transmission;</li>
        <li id="ul0002-0006" num="0051">Definition or specification of packet delivery mechanisms and a mechanism for reliable delivery of packets and recovering lost packets and/or disregarding damaged packets; and/or</li>
        <li id="ul0002-0007" num="0052">Definition of a mechanism for sending control data between network connected devices, machines and/or servers. This mechanism allows, for example, remote control of conversational engines.</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0047" num="0053">As indicated above, conversational protocols are preferably implemented on top of RTP so as to minimize the dialog delays introduced by distributed processing. A preferred embodiment for implementing conversational protocols on top of RTP based on the above criteria will be explained in detail below. First, an overview of a preferred embodiment utilizing RTP-based conversational protocols in accordance with such criteria will now be given.</p>
<p id="p-0048" num="0054">With respect to audio encoding and decoding mechanism and a file format for encoded audio data, the present invention preferably employs a well-defined conversational coding protocol comprising (1) a CODEC for encoding/decoding speech/audio data, which minimizes the distortion of the acoustic front-end features and allows reconstruction of intelligible waveforms and (2) a file format associated with the encoded speech/audio data (which is transmitted between network-connected devices/servers using a conversational transport mechanism discussed below). In a preferred embodiment, a conversational CODEC preferably compresses a cepstral feature stream while minimizing the distortion of the reconstructed features. In particular, any CODEC employing a compression scheme that minimizes the error rates of associated conversational engines and which allows for reconstruction/playback of the waveform in an intelligible manner (preferably in a perceptually acceptable manner) may be employed. For instance, any CODEC that compresses MEL cepstra feature vectors and adds pitch information is preferably employed.</p>
<p id="p-0049" num="0055">A preferred CODEC is the Recognition-Compatible VoCoder (RECOVC) which is discussed in greater detail below with reference to <figref idref="DRAWINGS">FIG. 2</figref>. Briefly, the preferred RECOVC system provides compression of the speech feature vectors such that, e.g., server-side speech recognition is not impaired, as well as reconstruction of a good quality, intelligible speech from the compressed speech feature vectors.</p>
<p id="p-0050" num="0056">Advantageously, when an audio subsystem of a client device employs an audio CODEC having the specific, well defined characteristics (as described above) for capturing and processing speech prior to transmission to a remote server for server-side processing, the main factors that affect the audio characteristics are related to the source and its acoustic environment. This minimizes the degradation of server-side audio processing, thereby providing increased accuracy of complex conversational tasks such as speech recognition and speaker recognition.</p>
<p id="p-0051" num="0057">In addition, any file format for the encoded audio data that comprises a header which defines information such as the compression algorithm, the size of the file, the audio parameters (feature type and dimension, sampling frequency, compression scheme), as well as other meta-information, if needed, such as language type and ancillary transformation information may be employed herein. In a preferred embodiment described in detail below with reference to <figref idref="DRAWINGS">FIGS. 3&#x2013;6</figref>, a preferred file format comprises a plurality of Blocks, each comprising compressed feature vectors of, e.g., several successive 10 msec audio frames, in such a way that each Block can be independently decompressed, thereby allowing a receiver to commence decompression from the middle of the file and/or skip damaged or missing data. Several Blocks are packed in a Segment with a Segment Header indicating the content type. Furthermore, as discussed in detail below, the preferred file format defines Speech, Silence, Ancillary Data and an End-of-Stream Segments.</p>
<p id="p-0052" num="0058">Furthermore, with respect to a streaming mechanism for minimizing the dialog delays introduced by remote processing, the present invention preferably employs RTP by extending the RTP header to enclose the CODEC file format. The resulting stream is referred to herein as RTCCP (Real Time Conversational Coding Protocol). This streaming mechanism is discussed in greater detail below with reference to, e.g., <figref idref="DRAWINGS">FIGS. 7</figref>, <b>8</b>, <b>9</b> and <b>10</b>. It is to be understood that the coded speech may also be encrypted to guarantee confidentiality (wherein encryption may be indicated in the header).</p>
<p id="p-0053" num="0059">Next, with respect to a mechanism for selecting the coding schemes, the present invention preferably utilizes the H.245 control standard by extending H.245 to include any supported conversational protocols. It is to be understood, however, that other protocols similar to H.323 (e.g., SIP) may be utilized.</p>
<p id="p-0054" num="0060">Moreover, with respect to a control mechanism, a preferred embodiment comprises extending RTCP (Real Time Control Protocol) to produce what is referred to herein as RTCCtP (Real Time Conversational Control Protocol). In particular, RTCCtP extends the functions of RTCP to provide a mechanism for selecting/switching the coding scheme in the middle of a stream transmission and for notification and confirmation. A preferred embodiment of RTCCtP is discussed below with reference to <figref idref="DRAWINGS">FIG. 12</figref>. With respect to packet delivery, the present invention preferably utilizes the reliability mechanisms of UDP and/or TCP or, in the absence of UDP or TCP, emulates functions similar to such protocols to recover lost packets and/or disregard packets. It is to be understood that any messaging to confirm delivery of packets can be used when reliable UDP or TCP is not available. This affects only the control layer. For instance, in case of lost packets, when reliability is needed, the unconfirmed packet can be requested and retransmitted.</p>
<p id="p-0055" num="0061">Furthermore, with respect to a mechanism for sending control data between the client and the speech server, the present invention preferably employs an extension of RTCP (i.e. an extension of RTCCtP) to add the extra information, to produce a control stream that is referred to herein as RTCDP (Real Time Conversational Distributed Protocol). Preferably, the control stream comprises any one or combination of the following: information about the data file (e.g., what data file to use and where to get it from); a description of the type of processing to apply (e.g., algorithm string&#x2014;sequence of actions to perform on the input or output by the conversational engines); the expected type and format of the results; an address where to return the results; exception handling mechanisms; I/O event notifications (e.g. for a distributed multi-modal browser); and/or modality specific view updates (e.g. ML (markup language) pushes to the modality specific viewing browsers in the multi-modal browser case).</p>
<p id="p-0056" num="0062">It is to be understood that in a Voice over IP environment comprising RSVP (Resource Reservation Protocol), the RSVP can be employed to allow pre-reservation of specific bandwidth and quality of service between two locations on the network so as to provide extra capability of traffic management.</p>
<p id="p-0057" num="0063">Referring to <figref idref="DRAWINGS">FIG. 1</figref>, a block diagram illustrates conversational protocols that may be implemented using the mechanisms/protocols described herein to support conversational computing and distributed architectures. The implementation of conversational protocols to provide distributed conversational computing, as well as the concepts and architecture to support uniform, coordinated conversational computing across a plurality of network connected pervasive computing devices and servers via universal and coordinated conversational user interfaces (as provided via a conversational virtual machine (CVM)), are described in detail, for example, in International Appl. No. PCT/US99/22927, filed on Oct. 1, 1999, entitled: &#x201c;Conversational Computing Via Conversational Virtual Machine,&#x201d; which is commonly assigned, and fully incorporated herein by reference (which claims priority from U.S. Provisional Patent Application Ser. Nos. 60/102,957, filed Oct. 2, 1998, and 60/117,595, filed Jan. 27, 1999, which are commonly assigned and the disclosures of which are also expressly incorporated herein by reference). A CVM platform may be employed herein to present consistent conversational services and behavior to the user and the application developer who can directly use these services and the platform interfaces to build conversational applications.</p>
<p id="p-0058" num="0064">Furthermore, the implementation of such conversational protocols in a distributed environment to provide automatic and coordinated sharing of conversational functions and resources between local and remote applications/devices/servers (without implementing a CVM platform) is described in detail, for example, in International Application No. PCT/US99/22925, filed on Oct. 1, 1999, entitled &#x201c;<i>System and Method For Providing Network Coordinated Conversational Services</i>,&#x201d; which is commonly assigned and incorporated herein by reference.</p>
<p id="p-0059" num="0065">Briefly, referring to <figref idref="DRAWINGS">FIG. 1</figref>, conversational protocols for implementing a distributed network architecture preferably comprise conversational distributed protocols <b>101</b>, discovery, registration, and negotiation protocols <b>102</b> and a speech transmission (or conversational coding) protocol <b>103</b>. In a preferred embodiment, the present invention addresses the real-time implementation of the conversational coding protocol <b>103</b> and conversational distributed protocols <b>101</b> (as well as other extensions using other Internet transport mechanisms for non real-time implementations). The implementation of real-time transmission of discovery, registration and negotiation protocols is not necessary in all instances, but nevertheless may be implemented on top of RTP in accordance with the teachings herein. Real-time negotiation can occur during the network connection and, consequently, the negotiation protocols can implemented on top of RTDCP (an other real-time control data stream structures described below).</p>
<p id="p-0060" num="0066">The conversational distributed protocols <b>101</b> allow networked (distributed) conversational applications <b>105</b>, <b>105</b><i>a </i>and network-connected devices (local client and other networked devices such as a server) to, e.g., register their current conversational state, arguments (data files) and context, share local and distributed conversational engines <b>108</b>, <b>109</b> between network connected devices (e.g., client/server), and otherwise exchange information to coordinate a &#x201c;conversation&#x201d; involving multiple devices or applications including master/salve conversational network, peer conversational network, and silent partners.</p>
<p id="p-0061" num="0067">The information that may be exchanged between networked devices using the conversational distributed protocols <b>101</b> comprises pointers to data files (arguments), transfer (if needed) of data files and other conversational arguments, notification for input, output events and recognition results, conversational engine API calls and results, notification of state and context changes and other system events, registration updates: handshake for registration, negotiation updates: handshake for negotiation, and discovery updates when a requested resource is lost.</p>
<p id="p-0062" num="0068">Preferably, the conversational distributed protocols <b>101</b> also comprise dialog management (DM) protocols that provide a mechanism for exchanging information between dialog managers (DMs) of networked devices. For example, in a distributed environment, dialog management protocols are used for exchanging information to determine which dialog manager will execute a given function. Typically, different devices, CVMs or different applications will have their own dialog manager and context stack. Through the exchange of information via DM protocols, the different dialog managers involved in a dialog session will negotiate a topology with a master dialog manager and slave or peer dialog managers, wherein the active master dialog manager will be responsible for managing the flow of I/O to the different managers to decide the active dialog and appropriately execute a query and update the context and/or history. For instance, the following information can be exchanged: (1) DM architecture registration (e.g., each DM can be a collection of locals DMs); (2) pointers to associated meta-information (user, device capabilities, application needs, etc.); (3) negotiation of DM network topology (e.g., master/slave, peer-to-peer); (4) data files (conversational arguments) if applicable (e.g., if engines are used that are controlled by a master DM); (5) notification of I/O events such as user input, outputs to users for transfer to engines and/or addition to contexts; (6) notification of recognition events; (7) transfer of processed input from engines to a master DM; (8) transfer of responsibility of master DM to registered DMs; (9) DM processing result events; (10) DM exceptions; (11) transfer of confidence and ambiguity results, proposed feedback and output, proposed expectation state, proposed action, proposed context changes, proposed new dialog state; (12) decision notification, context update, action update, state update, etc.; (13) notification of completed, failed or interrupted action; (14) notification of context changes; and/or (15) data files, context and state updates due to action.</p>
<p id="p-0063" num="0069">In a preferred embodiment of the present invention, the distributed conversational protocols <b>101</b> are implemented via extensions of RTP/RTCP (as described below). In another aspect, the distributed conversational protocols may be implemented on top of TCP via RMI (remote method invocation) or RPC (remote procedure call) system calls to implement the calls between the applications and the different conversational engines over the network. As is known in the art, RPC is a protocol that allows one application to request a service from another application across the network. Similarly, RMI is a method by which objects can interact in a distributed network. RMI allows one or more objects to be passed along with the request.</p>
<p id="p-0064" num="0070">Although the distributed conversational protocols may be implemented via RMI/RPC (as well as DCOM/ActiveX, Cobra, etc.), RTP is preferred because, e.g., RTP (i) takes advantage of the existing/emerging framework of Voice over IP (land and wireless), (ii) provides an open standard approach, (iii) does not make any assumptions on the OS/platform of the different entities, (iv) does not make any assumptions on the engines or APIs used by the different entities, and (v) can take advantage of the functions and services offered in the Voice Over IP framework and (vi) allows (when not encrypted) a third party and intermediary to appropriately modify and/or prepare the RTP stream to increase or improve the user experience.</p>
<p id="p-0065" num="0071">The speech transmission protocol <b>103</b> (or conversational coding protocol) are used by speech transmission clients <b>107</b>, <b>107</b><i>a </i>to transmit compressed speech (compressed speech file format <b>104</b> discussed below) to other networked devices, systems or applications for processing. The speech transmission clients <b>107</b>, <b>107</b><i>a </i>operate in conjunction with compression, decompression and reconstruction engines <b>110</b>, <b>110</b><i>a </i>(preferably using the CODEC techniques described below) and suitable compression hardware <b>111</b>, <b>111</b><i>a </i>for processing the speech (e.g., speech file <b>104</b>) transmitted over the network. As described below, the speech coders <b>110</b>, <b>110</b><i>a </i>provide perceptually acceptable or intelligible reconstruction of the compressed speech and optimized conversational performance (e.g., word error rate). The speech is captured (and transformed into features) on the respective networked devices using acoustic signal processing engines (audio subsystems) <b>112</b>, <b>112</b><i>a </i>and suitable audio hardware <b>113</b>, <b>113</b><i>a. </i></p>
<p id="p-0066" num="0072">In addition, a compressed speech file format <b>104</b> can be transmitted/streamed between devices for distributed speech processing using one of the real-time streaming methods described herein in accordance with the present invention. More specifically, the speech transmission protocol <b>104</b> allow the devices to transmit compressed speech or local processing results to other devices and applications on the network. In a preferred embodiment, after the handshake process between a source device and a receiver device, a data stream (packet based) is sent to the receiver. The packet headers preferably specify the coding scheme and coding arguments (i.e. sampling frequency, feature characteristics, vector dimensions, feature transformation/family, etc. In addition, error correcting information can also be introduced (e.g. last feature vector of the previous packet to correct the differential decoders if the previous packet is lost or delayed), or appropriate messaging to recover (re-send) lost packets.</p>
<p id="p-0067" num="0073">The conversational protocols further comprise conversational discovery (detection), registration, and negotiation protocols (or methods) <b>102</b>. The registration protocols allow networked devices or applications to exchange and register information regarding their conversational capabilities, state/context and arguments, so as to limit data transfer between the devices to relevant information and negotiate the master/slave or peer networking. By way of example, the registration protocols allow the following information to be exchanged: (1) capabilities and load messages including definition and update events; (2) engine resources (whether a given device includes NLU, DM, NLG, TTS, speaker recognition, speech recognition compression, coding, storage, etc.); (3) I/O capabilities (e.g., GUI, Voice, HTML, etc.); (4) CPU, memory, and load capabilities; (5) data file types (domain specific, dictionary, language models, languages, etc.); (6) network addresses and features; (7) information about a user (definition and update events); (8) user preferences for the device, application or dialog; (9) customization; (10) user experience; (11) help; (12) capability requirements per application (and application state) (definition and update events); (13) meta information for CUI services and behaviors (help files, categories, conversational priorities, etc.) (definition and update events, typically via pointer to table); (14) protocol handshakes; and/or (15) topology negotiation.</p>
<p id="p-0068" num="0074">Registration may be performed using a traditional communication protocol such as TCP/IP, TCP/IP <b>29</b>, JINI, T-Space, X-10 or CEBus, and socket communication between devices. The devices use a distributed conversational architecture to exchange information such as their conversational arguments (e.g., active vocabulary, grammars and language models, parsing and translation/tagging models, voice prints, synthesis rules, baseforms (pronunciation rules) and voice fonts). This information is either passed as files or streams to, e.g., a CVM controller and the conversational engines, or as URLs. In one embodiment for implementing the registration protocols, upon connection, the devices can exchange information about their conversational capabilities with a prearranged protocol (e.g., TTS English, any text, Speech recognition, 500 words and FSG grammar, no speaker recognition, etc.) by exchanging a set of flags or a device property object. Likewise, applications can exchange engine requirement lists. With a master/slave network configuration, the master dialog manager can compile all the lists and match the functions and needs with conversational capabilities. In addition, context information may be transmitted by indicating passing or pointing to the context stack/history of the device or application that the controller can access and add to its context stack. Devices can also pass information about their multi-modal I/O and UI capabilities (screen/no screen, audio in and out capabilities, keyboard, etc.) The conversational arguments allow a dialog engine to estimate the relevance of a new query by the NLU engine, based on the current state and context.</p>
<p id="p-0069" num="0075">The conversational discovery protocols <b>102</b> are utilized by spontaneously networked conversational clients <b>106</b>, <b>106</b><i>a </i>of the devices to automatically discover local or network conversationally aware systems and dynamically and spontaneously network-connect such conversationally aware systems. The information that is exchanged via the discovery protocols comprises the following: (1) broadcast requests for handshake or listening for requests; (2) exchange of device identifiers; (3) exchange of handles/pointer for first registration; and (4) exchange of handles for first negotiation. Discovery may also be implemented by accessing a central repository that comprises a description of the registered devices (via, e.g., LDAP (lightweight directory access protocol) or a home page/server that lists the registered devices).</p>
<p id="p-0070" num="0076">Furthermore, the negotiation protocols <b>102</b> allow the negotiation between master/slave or peer networking so as to provide the appropriate coordination between, e.g., multiple CVM systems in dynamic master-slave and peer-to-peer interactions. More specifically, multiple CVM devices when registering will add to the conversational registration capability, information pertaining to, e.g., their controlling capability, the conversational engines that they have access to, and applications and devices that have registered with them and that they control. Based on their UI, I/O capabilities and active I/O, one CVM controller becomes the master and the other CVM controllers act as slaves, which is equivalent relatively to the master as being registered applications until a new negotiation occurs. The role of master and slave can be dynamically switched based on the active I/O modality or device or based on the active application.</p>
<p id="h-0006" num="0000">II. Conversational Codec</p>
<p id="p-0071" num="0077">As indicated above, one component of conversational protocols for implementing for distributed conversational networking comprises a suitable audio coding/decoding (Codec) protocol. Referring now to <figref idref="DRAWINGS">FIGS. 2</figref><i>a </i>and <b>2</b><i>b</i>, a block diagram illustrates an audio CODEC (coder/decoder) system which may be employed for use with the present invention for encoding/decoding speech data that is transmitted using the conversational protocols and methods described herein according to the present invention. More specifically, in a preferred embodiment, the CODEC depicted in <figref idref="DRAWINGS">FIG. 2</figref> is a Speech-Recognition Compatible Voice Coder RECOVC&#x2122; (RECOVC is a registered trademark of International Business Machines Corporation). The RECOVC&#x2122; system developed by IBM Corporation addresses various issues including:
<ul id="ul0003" list-style="none">
    <li id="ul0003-0001" num="0000">
    <ul id="ul0004" list-style="none">
        <li id="ul0004-0001" num="0078">1. Compression of speech recognition feature vectors, such that recognition rates are not impaired; and</li>
        <li id="ul0004-0002" num="0079">2. Reconstruction of a good quality, intelligible speech from the speech recognition feature vectors.
<br/>
A detailed discussion of components of the RECOVC system depicted in <figref idref="DRAWINGS">FIG. 2</figref> can be found in U.S. Pat. No. 6,009,387, issued on Dec. 28, 1999 to Ramaswamy, et al., entitled &#x201c;<i>System and Method Of Compression/Decompressing A Speech Signal By Using Split Vector Quantization And Scalar Quantization</i>,&#x201d; and U.S. application Ser. No. 09/410,085, filed on Oct. 1, 1999, entitled &#x201c;<i>Method and System For Low Bit Rate Speech Coding Using Speech Recognition Features</i>,&#x201d; now abandoned which are commonly assigned and fully incorporated herein by reference. The RECOVC may be operated in two modes. A first mode comprises a full RECOVC implementation employing compression and speech reconstruction. A second mode of operation comprises feature vector compression and decompression only, without speech reconstruction. A brief summary of the RECOVC&#x2122; system according to one embodiment will now be provided.
</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0072" num="0080"><figref idref="DRAWINGS">FIG. 2</figref><i>a </i>depicts a block diagram of an encoding portion <b>200</b> of a RECOVC codec according to one embodiment, optionally coupled with a speech recognition engine <b>201</b> (located on e.g., a client device) for converting input speech into text. An input speech signal is fed into an acoustic front-end <b>202</b>) comprising an analog-to-digital (A/D) converter (<b>203</b>), a window/filter module (<b>204</b>), a short-time fourier transform analysis (STFT) module (<b>205</b>) and a cepstral analysis module (<b>206</b>). The analog input speech signal is digitized by the A/D converter <b>203</b> and partitioned into short duration frames (typically 10 ms) via the window/filter module (<b>204</b>). A feature vector is produced for each frame of digitized input speech. It is to be understood that any suitable feature extraction method may be implemented herein such as IBM's ViaVoice&#x3c5; system, or any other voice recognition systems implementing a Short-Time Fourier Transform (STFT) analysis (<b>205</b>) and cepstral analysis (<b>206</b>) process for extracting the mel-frequency cepstral coefficient (MFCC) feature vector (which represents the spectral envelope of the speech). The MFCC feature vectors can then be used by the speech recognition &#x201c;back-end&#x201d; (<b>201</b>) for converting the input speech signal into text.</p>
<p id="p-0073" num="0081">The MFCC feature vectors are preferably compressed via MFCC compression module (<b>208</b>) using any technique known to those skilled in the art that provides compression without effecting the performance of the speech recognition system. Preferably, the compression module <b>208</b> preferably implements the compression scheme disclosed in the above-incorporated U.S. Pat. No. 6,009,387 (although other suitable compression schemes may be utilized). The compression scheme disclosed in this patent utilizes a first order prediction, multistage split VQ technique. Preferably, the bit rates are in the range 4&#x2013;6.4 kbps, depending on the size of the MFCC feature vector. It is to be appreciated that the preferred compression approach is flexible in terms of acoustic feature characteristics such as dimensions or sampling rates. It is to be further appreciated that when used in combination of robust front-ends, the features may be compressed prior to transformation. The transformations are transmitted separately as described in detail below. On the receiving end, the transformations are applied after decompression.</p>
<p id="p-0074" num="0082">To provide speech reconstruction and playback using the MFCC feature vectors, an additional pitch frequency information (including voiced/unvoiced decisions) is extracted for every frame of speech data via a voice decision and pitch detection module (<b>207</b>) together with the respective MFCC feature vector. It is to be appreciated that the pitch data is efficiently calculated from the STFT module <b>205</b> using a spectral peak detection process. It is to be understood that for some speech recognition systems, especially for tonal languages (e.g. Mandarin Chinese), the pitch information that is used for recognition and pitch detection is already implemented as a part of the front-end process.</p>
<p id="p-0075" num="0083">The pitch period values are compressed at bit rates of 300&#x2013;500 bps via a pitch compression module <b>209</b>. The streams of compressed MFCC feature vectors and the compressed pitch are multiplexed via MUX <b>210</b> to form an output bitstream (of coded cepstra and pitch) for storage and/or transmission.</p>
<p id="p-0076" num="0084">Referring now to <figref idref="DRAWINGS">FIG. 2</figref><i>b</i>, a block diagram illustrates a speech decoder <b>211</b> of a RECOVC&#x2122; CODEC according to one embodiment which generates a reconstructed speech signal (for playback) of the encoded bitstream generated by the encoder <b>200</b>. The decoder <b>211</b> is optionally coupled with a speech recognition engine <b>212</b> for converting the decompressed speech to text. The encoded input bit stream is fed into a de-multiplexer (<b>213</b>) which separates the bit stream into a stream of compressed MFCC feature vectors and a stream of compressed pitch. The MFCC vectors are decompressed via decompression module (<b>214</b>) (using the techniques described in the above-incorporated U.S. Pat. No. 6,009,387). A pitch decompression module (<b>215</b>) decompresses the encoded pitch information if playback of the speech is required or if pitch is needed for the speech recognition process (<b>212</b>).</p>
<p id="p-0077" num="0085">It is to be appreciated that the speech for playback is reconstructed from the decoded MFCC feature vectors and the decoded pitch values via a sinusoidal speech synthesis module <b>216</b>, which preferably employs a novel, low complexity, frequency domain reconstruction method described in detail in the above-incorporated patent application U.S. Ser. No. 09/410,085. The reconstruction is performed using a sinusoidal speech model (such as described by R. Mc Aulay et al., Sinusoidal Coding, Speech Coding and Synthesis, Chapter 4, pages 121&#x2013;170, Elsevier, 1995.) The values of the model parameters are determined such that the reconstructed speech has an MFCC feature vector similar to the decoded MFCC feature vector, and a pitch similar to the decoded pitch. This is sufficient to reconstruct natural sounding, good quality, intelligible speech with the voice of the original speaker.</p>
<p id="p-0078" num="0086">It is to be appreciated that the RECOVC system described above using a cepstral feature compression scheme minimizes the level of degradation of the performances of a conversational task performed on the decompressed feature stream. The preferred compression scheme is a key basic element of conversational networking. It is to be understood, however, that any suitable coding scheme that compresses the cepstral feature stream while minimizing the distortion of the reconstructed features may be used herein. In addition, for practical purposes, a preferred coding scheme for use in conversational distributed environment is one that supports reconstruction of intelligible waveforms. Indeed, this reconstruction is useful for later playback from the server or playback from the client (if stored locally) or for subsequently proofreading the transcription, error correction, or human monitoring of the process. Accordingly, any conversational CODEC that minimizes the distortion of the acoustic front-end features and allows reconstruction of intelligible waveforms may be employed herein. For example, any conventional CODEC combined with an acoustic feature error correction/minimization scheme would fit the definition. Preferably, such coding schemes should provide data rates as low as between 4 kbits/s and 5 kbit/s with no degradation of the recognition performances. As a result, interactive exchanges can be performed in real time with the back-end (server) resources even over wireless modems or wireless data links.</p>
<p id="p-0079" num="0087">It is to be understood that although a preferred CODEC system and method is described above, it is to be appreciated that the transmission of speech from the local client to a remote network-connected server (or vice versa) can be performed using other techniques depending on the circumstances and desired results. For instance, there can be direct transmission of the waveform as a file, a stream or a stream of packets. In addition, a compressed waveform may be transmitted using conventional methods such as ADPCM and APC. Furthermore, a stream of features can be transmitted in accordance with the method disclosed in &#x201c;Compression Of Acoustic Features For Speech Recognition In Network Environments,&#x201d; by G. Ramaswamy et al., Vol. 2, pp. 977&#x2013;980, Proc. ICASSP, 1998, which is incorporated herein by reference. This method allows recognition (speech recognition, speaker recognition or NLU) on the receiver side but no reconstruction of the signal.</p>
<p id="h-0007" num="0000">III. Conversational Coding Protocols</p>
<p id="p-0080" num="0088">(A) File Format</p>
<p id="p-0081" num="0089">As indicated above, one component for defining a conversational coding protocol comprises a definition of the file format that is associated with the encoded data. In a preferred embodiment, the CODEC system and method (and feature compression scheme) described above (i.e., RECOVC) is used for generating an internal file format that can be utilized for real-time distributed conversational interactions. Referring now to <figref idref="DRAWINGS">FIG. 3</figref>, a block diagram illustrates a RECOVC file format according to an embodiment of the present invention (which may be referred to herein as &#x201c;RECOVC.xxx&#x201d;). It is to be appreciated that a preferred RECOVC file format according to the present invention enables transmission of different segments of speech. As illustrated in <figref idref="DRAWINGS">FIG. 3</figref>, a preferred RECOVC.xxx file format comprises a File Header which, in general, defines information regarding, e.g., the compression scheme, the size of the file, the audio parameters (feature type and dimension), sampling frequency, and other meta-information such as language type, encryption information and ancillary transformation information regarding transformation of the speech signal, if needed, etc. It is to be understood that although the RECOVC.xxx file format is preferred, other file formats may be employed herein comprising a structure that provides the above-mentioned meta-information.</p>
<p id="p-0082" num="0090">A preferred format of the RECOVC file comprises a plurality of Blocks, each comprising compressed feature vectors of several successive 10 msec audio frames, for example. More specifically, in a preferred embodiment, each Block comprises a single IntraFrame (comprising uncompressed or losslessly compressed) speech features and one or more InterFrames having speech data coded using RECOVC. More specifically, an IntraFrame is the first frame of a Block that is preferably non-encoded or, alternatively encoded by different schemes that guarantees that the IntraFrame can be recovered/reconstructed, even if previous blocks or frames have been corrupted. Moreover, an InterFrame is a frame between IntraFrames. The InterFrames may be coded differently than the IntraFrames, as it may be less critical to have them corrupted (since the stream will be recovered at the next IntraFrame. Robust encoding, including error correcting codes may be used for the InterFrames.</p>
<p id="p-0083" num="0091">The (maximum) number of frames N<b>1</b> for each Block is specified in the File Header. The feature vectors are stored in Blocks in such a way that each Block can be decompressed on its own. It is to be appreciated that this allows decompression to be performed at any portion (e.g., the middle) of the RECOVC File, as well as skipping damaged or missing data.</p>
<p id="p-0084" num="0092">The RECOVC File further comprises one or more Segments, comprising, e.g., speech and silence segments, all of which are preceded by a corresponding Segment Header. For instance, each speech Segment comprises several Blocks and a Speech Segment Header indicating the type of content (e.g., speech). The Speech Segment Header specifies the number of frames (N<b>2</b>, N<b>4</b>) per speech Segment. The RECOVC file further comprises one or more of Silence Segments and EOS Segments (end-of-stream), as well as ancillary data segments that may be defined depending on the application.</p>
<p id="p-0085" num="0093">Referring now to <figref idref="DRAWINGS">FIG. 4</figref>, a diagram illustrates information that is preferably included within a File Header of a RECOVC file according to the present invention. The File Header comprises a plurality of fields, some of which are mandatory and some of which are optional. For example, the Header Length comprises a 2 byte field that indicates the total number of bytes in the File Header. A Frame Duration field comprises a 1 byte field that comprises an index to a Frame Duration Table illustrated in <figref idref="DRAWINGS">FIG. 5</figref>. The Frame Duration Table comprises a plurality of Codes each specifying the duration (in msec) of each frame of speech. A Frames Per Block field comprise a 1 byte field having a value that specifies the maximum number of allowed frames per Block. Each Block (<figref idref="DRAWINGS">FIG. 3</figref>) may comprise only one Intra-Frame, or one Intra-Frame and one or more Inter-Frames. A Sampling Rate field comprises a 1 byte field that provides an index value to a Sampling Rate Table (<figref idref="DRAWINGS">FIG. 5</figref>). The Sampling Rate Table comprises a plurality of Codes each specifying the input sampling rate (Hz) of the speech data.</p>
<p id="p-0086" num="0094">A Cepstra Dimension field (<figref idref="DRAWINGS">FIG. 4</figref>) comprises a 1 byte field having index value to a Cepstra Vector/Type Table (<figref idref="DRAWINGS">FIG. 5</figref>). The Cepstra Vector/Type Table comprises a plurality of codes each specifying a dimension of the cepstral feature vectors. A Language field comprises a 1 byte field having index value to a Language Table. The Language Table comprises one or more codes each specifying a language of the encoded speech data. A Profile field comprises a 1 byte field having an index value to a Profile Table (as illustrated in <figref idref="DRAWINGS">FIG. 6</figref>). The Profile Table comprises a plurality of codes each specifying, e.g., whether the speech data contains information that enables recognition only or recognition and reconstruction of the speech data.</p>
<p id="p-0087" num="0095">Referring to <figref idref="DRAWINGS">FIG. 6</figref>, the Speech and Silence Segment Headers (shown in <figref idref="DRAWINGS">FIG. 3</figref>) preferably comprise a 5 byte field comprising a 1 byte Segment Type field and a 4 byte Number Of Frames field. The Segment Type field comprises a index value in a Segment Type Table indicating the type of Segment (speech or silence). If speech is included is a given Segment, a Speech Segment Header will specify the number of frames for the given Segment. If speech is not included in a given silence Segment, the silence Segment does not need to be transmitted. If the given silence Segment is transmitted, is can be marked via a Silence Segment Header that specifies the number of silence frames for the given silence Segment (which can then be ignored by a recognition engine on the receiver of the data stream.</p>
<p id="p-0088" num="0096">The Number of Frames field comprises a value that indicates the total number of frames of the corresponding Segment. As further illustrated in <figref idref="DRAWINGS">FIG. 6</figref>, EOS Headers and Data Segment Headers preferably comprise a 5 byte (minimum) field comprising a 1 byte Segment Type field and a 4 byte Segment Length field. The Segment Type field comprises an index value to a Segment Type table indicating the type of segment (EOS or Data). The Segment Length field includes a value that indicates the total number of bytes of the corresponding Segment. In addition, Ancillary Data with corresponding segment header, etc., may be defined and incorporated into the RECOVC file format accordingly.</p>
<p id="p-0089" num="0097">(B) Conversational Streaming and Control Mechanisms</p>
<p id="p-0090" num="0098">As indicated above, a suitably defined streaming mechanism is implemented to transmit the RECOVC file for distributed conversational applications. Packetization of the RECOVC file format is preferably achieved by buffering the data stream block by block (and initially sending the header). Typically with 300 ms packets, the data rate can be as low as 4 kbit/s (4.5 kbit/s when reconstruction of the waveform is not required). This is sufficient for real-time low bit rate transmission even over wireless modem and real-time interaction. Packetization will be discussed in detail below.</p>
<p id="p-0091" num="0099">In a preferred embodiment, packet transmission of a RECOVC data stream (as shown in <figref idref="DRAWINGS">FIG. 3</figref>) for wireless, UDP, TCP/IP, HTTP and Voice over IP networks is implemented using a conventional RTP (Real-time Transport Protocol) to wrap the resulting RECOVC data stream. The term RTCCP (Real-time Conversational Coding Protocol) is used herein to refer to a RECOVC data stream that is wrapped in a conventional RTP stream. As is known in the art, RTP is a standardized protocol that provides end-to-end network transport functions suitable for applications transmitting real-time data such as audio or video over a network (e.g., distributed applications). RTP does not provide a mechanism to ensure timely delivery of the data or provide other quality of service guarantees, but relies on lower-layer services for such services. As is further known in the art, the data transmission (via RTP) is augmented by RTCP (RTP control protocol) that allows monitoring of the data delivery and provides minimal control and identification functionality. In accordance with a preferred embodiment of the present invention, RTP is extended through modifications and/or additions to the headers as necessary for incorporating the RECOVC File format to provide real-time streaming of the RECOVC data.</p>
<p id="p-0092" num="0100">A brief discussion of a standard RTP protocol will now be provided with reference to the diagram of <figref idref="DRAWINGS">FIG. 7</figref>, which illustrates a format of an RTP Header <b>700</b> according to the prior art. The RTP header <b>700</b> is a conventional RTP header where an extension capability of the RTP header is utilized to add the RecoVC information. The first 12 bytes (96 bits) of the RTP header <b>700</b> (or fixed header) are included in every RTP packet, while a list of CSRC (contributing source) identifiers <b>710</b> may be included when inserted by a mixer (as is known in the art, a mixer is an intermediate system that receives RTP packets from one or more sources, processes the packets as necessary, and combines the packets in some manner and then forwards a new RTP packet).</p>
<p id="p-0093" num="0101">The RTP header <b>700</b> comprises a version number field <b>701</b> (2 bits) which identifies the version of RTP. The most current version of RTP is version &#x201c;2&#x201d;. A padding (P) field <b>702</b> comprises a 1 bit field, whereby if the padding bit is set, this indicates that the packet contains one or more additional padding bytes at the end which are not part of the payload. The last byte of the padding contains a count of the number of padding bytes that should be ignored. This padding (bytes of value 0) is added to the end of the payload of an RTP packet so as to maintain the 32-bit fields aligned at offsets divisible by four.</p>
<p id="p-0094" num="0102">An extension (X) field <b>703</b> is a one bit field that is set to indicate that a variable-length header extension is appended to the RTP header, following the CSRC list <b>710</b> (if present). A CSRC count (CC) field is a 4 bit field that indicates the number of CSRC identifiers that follow the fixed header (i.e., the first 12 bytes). A marker (M) field <b>705</b> is a 1 bit field that carries profile-specific information. A profile specifies a default static mapping of payload type codes to payload formations. The marker is intended to allow significant events such as frame boundaries to be marked in the packet stream. A profile may define additional maker bits or specify that there is no marker bit by changing the number of bits in the payload type field <b>706</b>.</p>
<p id="p-0095" num="0103">The payload type field <b>706</b> is a 7 bit field that identifies the format of the RTP payload and determines its interpretation by the application. The RTP payload is the data transported by RTP in a packet. As indicated above, a profile specifies a default static mapping of payload type codes to payload formats.</p>
<p id="p-0096" num="0104">A sequence number field <b>707</b> is a 16 bit field that comprises a sequence number of the RTP packet. The sequence numbers allows the receiver to reconstruct the sender's packet sequence. The sequence numbers may also be used to determine the proper location of a packet, for example in audio decoding, without necessarily decoding packets in sequence. The sequence number increments by one for each RTP data packet that is sent, and may be used by the receiver to detect packet loss and to restore packet sequence.</p>
<p id="p-0097" num="0105">A time stamp field <b>708</b> is a 32 bit field that indicates the time of sampling of the first byte in the RTP data packet. The time stamp may be derived via NTP (network time protocol) or other clocking methods known to those skilled in the art for providing synchronization depending on the application.</p>
<p id="p-0098" num="0106">A synchronization source (SSRC) identifiers field <b>709</b> is a 32 bit field that indicates the synchronization source of a stream of RTP packets. This identifier is chosen randomly and is identified by a 32-bit numeric SSRC identifier carried in the RTP header so as not to be dependent upon the network address.</p>
<p id="p-0099" num="0107">The CSRC identifiers <b>710</b> field is a 32 bit field that identifies the contributing sources, if any, for the payload contained in the packet. A source of stream of RTP packets that has contributed to the combined stream produced by an RTP mixer. The mixer inserts a list of the SSRC identifiers of the sources that contributed to the generation of the particular packet into the RTP header of that packet. An example application is audio conferencing where a mixer indicates all the persons who speech was combined to produce the outgoing packet so that the receiver can determine the current talker, even though all the audio packets contain the same SSRC identifier (i.e., the SSRC identifier of the mixer).</p>
<p id="p-0100" num="0108">In accordance with a preferred embodiment of the present invention, the RTP format described above with reference to <figref idref="DRAWINGS">FIG. 7</figref> is extended to encompass the RECOVC data stream discussed above with respect to, e.g., <figref idref="DRAWINGS">FIG. 3</figref>. More specifically, profile-specific modifications may be made to the RTP header <b>700</b> of <figref idref="DRAWINGS">FIG. 7</figref> based on the profile of the RECOVC format to generate what is referred to herein as RTCCP.</p>
<p id="p-0101" num="0109"><figref idref="DRAWINGS">FIG. 8</figref> is a diagram illustrating the extension of RTP to produce RTCCP according to one aspect of the present invention. In the embodiment of <figref idref="DRAWINGS">FIG. 8</figref>, the additional information for the RECOVC payload is carried in the payload section of the RTP packet. As indicated above, an RTP packet comprises the fixed RTP header, a possible empty list of contribution sources, and the payload data. In accordance with one aspect of the present invention, a profile-specific extension to the RTP header comprises a 16 bit Codec Identifier field <b>801</b>, an RTP Header Extension Length field <b>802</b>, followed by a Codec Header field <b>803</b>. In the preferred embodiment using RECOVC, the codec identifier <b>801</b> comprises a value for .xxx in RECOVC.xxx that indicates parameters of the different RECOVC codecs, wherein the RECOVC.xxx codec nomenclature is as follows: RECOVC.{sampling rate code}{Cepstra Vector Dimension Code}{Profile Code} Preferably, a default RECOVC codec, RECOVC.101, comprises the following default settings: {11 kHz sampling frequency code}=1, {13 dimensional cepstra code}=0 and {+pitch compressed at 4.5 kbit/s}=1 (before packetization), as indicated in the respective tables of <figref idref="DRAWINGS">FIGS. 5 and 6</figref>.</p>
<p id="p-0102" num="0110">The RTP header extension length field <b>802</b> is a 16 bit field that counts the number of 32-bit words in the extension, excluding the 4-bytes comprising fields <b>801</b> and <b>802</b> of the RTP header extension. Moreover, in a preferred embodiment, the codec header field <b>803</b> comprises the RECOVC header (<figref idref="DRAWINGS">FIGS. 3 and 4</figref>) and payload data (i.e., the RECOVC header is included as RTP header extension. Furthermore, in an RTP packet comprising a RECOVC extension, the X bit is set to one, indicating that a variable length header extension is appended to the RTP header. The resulting stream of extended RTP packets constitutes a preferred RTCCP stream (Real-Time Conversational Coding protocol) according to the present invention.</p>
<p id="p-0103" num="0111">Referring now to <figref idref="DRAWINGS">FIG. 9</figref>, a block diagram illustrates a system/method for streaming/packetizing RTCCP data. An audio source (codec) <b>900</b> generates audio/speech data to be transmitted over a network <b>901</b> to a receiver <b>902</b>. The transmitter comprises a system manager <b>903</b> which manages a an audio buffer and RTCCP generator <b>905</b>. The audio source <b>900</b> preferably comprises the RECOVC encoder <b>200</b> (<figref idref="DRAWINGS">FIG. 2</figref><i>a</i>) and the receiver preferably comprises the RECOVC decoder <b>211</b> of <figref idref="DRAWINGS">FIG. 2</figref><i>b</i>. The packetization of the RECOVC file format received from the audio source <b>900</b> is preferably achieved by buffering (via the audio buffer <b>904</b>) the data stream block by block (and initially sending the header). More specifically, as illustrated in <figref idref="DRAWINGS">FIG. 10</figref>, each RTCCP packet output from the RTCCP generator <b>905</b> comprises one or more Blocks (<figref idref="DRAWINGS">FIG. 3</figref>). If silence Segments are dropped (not transmitted, corresponding time stamps can be transmitted to indicate the delay that can be introduce therebetween. If desired, silence information can be communicated by sending the information according to the RECOVC file format (<figref idref="DRAWINGS">FIG. 3</figref>). For real-time dialogs, with human or machines, the buffer size is preferably 300 ms maximum. Typically with 300 ms packets, the data rate can be as low as 4 kbit/s (4.5 kbit/s when reconstruction of the waveform is not required). This is sufficient for real-time low bit rate transmission even over wireless modem and real-time interaction. For deferred interaction, however, it is to be understood that the packet size can be a large as desired.</p>
<p id="p-0104" num="0112">If desired, error correction can be performed on a block by block basis. Preferably, a data Segment, defined by the RECOVC file formation, can be included which contains the error recovery information. More specifically, as shown in <figref idref="DRAWINGS">FIG. 6</figref>, error correction presence and type may be defined by the first bytes of an Ancillary Data field (Data Segment Header) by including (1) the size of the ECC information (where value of &#x201c;0&#x201d; indicates no ECC) and (2) and ECC identifier.</p>
<p id="p-0105" num="0113">It is to be appreciated that, as discussed in detail above, the RTCCP can run on top of an unreliable protocol such as UDP for real-time applications. When real-time is not an issue, RTCCP can be implemented on top of a reliable transport layer that will guarantee appropriate packet ordering and delivery such as TCP (transmission control protocol). This is illustrated in <figref idref="DRAWINGS">FIG. 11</figref>.</p>
<p id="p-0106" num="0114">As indicated above, because multiple conversational codecs can be utilized (e.g. RECOVC with different settings), a protocol/mechanism should be defined to select a coding scheme. For instance, the endpoints, e.g., source and receiver, must negotiate to determine compatible settings before the audio data and/or data communication links can be established. The present invention preferably utilizes the control functions defined by the H.245 standard (which is known to those skilled in the art), which specifies messages for opening and closing channels for media streams, and other commands, requests and indications to provide such control functions. More specifically, an initial connection between a source and receiver starts with a preliminary handshake, similar to H.245, except that it incorporates all the different conversational codecs (e.g., RECOVC) that are employed in the given application. The extension of the H.245 control and handshake protocol is referred to herein as H.245.RTCCP.</p>
<p id="p-0107" num="0115">More specifically, the default for transmission is set to RECOVC.101 (rather than G.711 (audio codec, 3.1 Khz at 48, 56, and 64 Kbps (normal telephony) or G.723 (Audio codec, for 5.3 and 6.3 Kbps modes) as currently prescribed by H.245) which is supported by all end points in the network. Aurora DSR or other schemes may also be supported. In real-time mode, RECOVC.101 is a preferred default codec that is initially enabled/selected upon system connect unless an agreement is reached to select another coding scheme before completion of the handshake, in which case the agreed upon coding scheme will be implemented.</p>
<p id="p-0108" num="0116">As further indicated above, a control protocol/mechanism should be defined for switch a coding scheme in the middle of a RTCCP stream transmission. In accordance with a preferred embodiment, notification and confirmation messages are transmitted as control extensions to the RTCP (Real Time Control protocol), resulting in what is referred to herein as RTCCtP (Real time Conversational Control Protocol). This architecture is illustrated in <figref idref="DRAWINGS">FIG. 11</figref>.</p>
<p id="p-0109" num="0117">As is known in the art, RTCP is based on a periodic transmission of control packets to all participants in a session, using the same distribution mechanism as the RTP packets. The underlying transport protocol must provide multiplexing of the data and control packets, for example, using separate port numbers with UDP. As is further known in the art, the RTCP specification defines several RTCP packet types to carry a variety of control information, where each RTCP packet type is allocated a unique identification code. For instance, the RTCP packet types include sender reports (SR) (code <b>200</b>) for transmission and reception statistics from participants that are active senders, as well as receiver reports (RR) (code <b>201</b>) for reception statistics from participants that are not active senders. RTP receivers provide reception quality feedback using RTCP report packets which may be SR or RR reports, depending on whether or not the receiver is also a sender. The only difference between the sender report (SR) and the receiver report (RR) forms, besides the packet type code, is that the SR includes a 20-byte sender information section for use by active senders. The SR is issued if a site has sent any data packets during the interval since issuing the last report or the previous one, otherwise the RR is issued. Other packet types include source description (SDES) (code <b>202</b>) packets comprising source description items such as CNAME (canocial end-point identifier), BYE packets (code <b>203</b>) to indicate end of participation, and APP packets (code <b>204</b>) for application specific functions.</p>
<p id="p-0110" num="0118">As is known in the art, each RTCP packet begins with a fixed header similar to that of RTP data packets, followed by structure elements that may be of variable length according to the packet type, but which always end on a 32-bit boundary (so as to allow RTCP packets to be &#x201c;stackable&#x201d; or concatenated to form a compound RTCP packet that is sent in a single packet of the lower layer protocol, e.g., UDP).</p>
<p id="p-0111" num="0119">In accordance with a preferred embodiment of the present invention, in addition to the conventional RTCP functions, RTCP is extended to RTCCtP to include application specific functions for conversational distributed functions. More specifically, in addition to the conventional RTCP functions, RTCP sender and receiver reports, for example, can be extended with suitable profile-specific extensions to support coding scheme notifications (signal/agree on changes of coding schemes). Other application specific extensions for conversational distributed functions include, e.g., RTCCtP identifiers, header extension length, code bits for RTCCtP functions, packet receipt request and acknowledgments, and codec change notification/request for confirmation, etc. These messages are propagated through the RTCP layer associated with the RTP stream.</p>
<p id="p-0112" num="0120">By way of example, for purposes of error correction, RTCCtP messages can require packet repetition and provide the packet sequence number of the packets to be repeated. In one embodiment, the RECOVC header of the RTCCP packet is repeated based on the receivers report (RR) in the RTCCtP stream. In a default case, the RECOVC header is repeated until confirmation is obtained from the receiver. The receiver must confirm to the sender the receipt of an X=1 packet and provide the packet ID/sequence number.</p>
<p id="p-0113" num="0121">It is to be understood that in the absence of RTP/RTCP, to provide control, the source may transmit the RECOVC header until confirmation is received by the source for all registered receivers. Moreover, in the absence of RTP support by the transport layer, similar functions must be emulated between clients and servers. Furthermore, in the absence of RTCP support by the transport layer, similar functions must be emulated between the clients and servers.</p>
<p id="p-0114" num="0122">It is to be appreciated that in accordance with another aspect of the present invention, RTCCtP may be further extended to transmit other application-specific control data between, e.g., a client (source) and a speech server (receiver) for providing conversational distributed functions. In a preferred embodiment, when additional RTCP packets are needed for immediate information transfer, the APP RTCP packet type (code <b>204</b>) noted above is preferably utilized to provide an application-specific extension for implementing the conversational distributed functions. A preferred complete control protocol is referred to herein as RTCDP (Real-Time Conversational Distributed Protocols). This is illustrated in <figref idref="DRAWINGS">FIG. 13</figref>, where, preferably, RTCCP is implemented on top of UDP (real-time) or TCP (non real-time) and a reliable layer carries RTCP, RTCCtP and RTCDP. It should be noted that control data may also be conveyed via other conventional connections such as sockets, RPC, RMI and HTTP.</p>
<p id="p-0115" num="0123">Referring to <figref idref="DRAWINGS">FIG. 12</figref>, a diagram illustrates an extension of RTCP/RTCCtP to implement the preferred RTCDP. <figref idref="DRAWINGS">FIG. 12</figref> illustrates a preferred method for implementing RTCDP by adding (to the RTCCtP header) another header to carry the control data. An RTCCtP header <b>1200</b> (which comprises and extension of the RTCP header) is preferably extended by adding a 16 bit identifier field <b>1201</b> indicating the type of conversational distributed protocol (e.g., remote control of an engine, or a synchronization or negotiation protocol, etc.), when such nomenclature is implemented (if none exists, the field <b>1201</b> may be used for padding). Further, a 16-bit header extension length field <b>1202</b> describes the length of the header. A data field <b>1203</b> carries a message of the streamed protocol in successive 32 bit fields.</p>
<p id="p-0116" num="0124">It is to be appreciated that depending on the application, any suitable application-specific control data can be transmitted between, e.g., a source and a receiver using RTCCtP for providing conversational distributed functions. For example, the protocols and APIs described above in connection with the above-incorporated International Appl. Nos. PCT/US99/22927, filed on Oct. 1, 1999, entitled: &#x201c;Conversational Computing Via Conversational Virtual Machine,&#x201d; and International Application No. PCT/US99/22925, filed on Oct. 1, 1999, entitled &#x201c;<i>System and Method For Providing Network Coordinated Conversational Services</i>,&#x201d; may be implemented to transmit control parameters and messages to support remote control of a speech engine (e.g., start/stop recognition), determine type of recognition to perform (e.g., speech, TTS, speaker recognition, NL parsing, NL tagging, Dialog Management, etc.), what data files to use (e.g., grammar files, acoustic models, language models, tagger data files, parser data file, dialog information, etc.), where and how results of, e.g., a recognition, should be sent, as well as messages that are needed to register, negotiate, and synchronize different engines.</p>
<p id="p-0117" num="0125">Furthermore, with Voice Browsers and Multi-Modal Browsers (as described below) and other applications, the control messages of RTCCtP may be transmitted as XML data (e.g., URLs pointing to particular algorithms, data files, and engines to be implemented) or byte code representation of XML tags (preferably, XML name space convention according to CML) and values associated with necessary control information. Such control information comprises: field identifiers and/or browser event identifiers (when also sent to Multi-modal shell (described below); argument data file(s) for the engines; format of the result/output to be specified (e.g., audio format (e.g., RTP stream) or text (ASCII, XML, attribute value pairs) or function call), with extra tag information and address of browser to push data; address and method/protocol to send results (back to browser or content server); identifier for the results, and commands to execute. Furthermore, when the stream is sent to a speech server, the XML tags associated with the active input are sent: field information for a directed dialog, active forms (or URLs of forms) for mixed initiative NL, etc. It is to be noted that the packets of streamed XML and protocols may be implemented using SOAP (simple object access protocol). In summary, RTCCtP may be used to transmit all types of control messages depending on the implementation.</p>
<p id="p-0118" num="0126">Referring now to <figref idref="DRAWINGS">FIG. 14</figref><i>a</i>, a diagram illustrates a system/method for implementing a distributed conversational framework using proxy servers according to one aspect of the present invention. The exemplary system of <figref idref="DRAWINGS">FIG. 14</figref><i>a </i>comprises an engine proxy <b>1420</b>, which operates on behalf of a browser application <b>1421</b>, and a browser proxy <b>1430</b>, which operates on behalf of conversational engines <b>1431</b>. More specifically, for this application, RTCDP is preferably utilized by the proxies <b>1420</b>, <b>1430</b> for exchanging control data to enable the engine proxy <b>1420</b> to effectively operate as a local speech engine for the browser, and to enable the browser proxy <b>1430</b> to effectively operate as a local browser for the engines <b>1431</b>. The engines <b>1431</b> will directly communicate with the browser proxy <b>1430</b> using suitable speech engine APIs and the browser <b>1421</b> will communicate with the engine proxy <b>1420</b> using the same engine APIs.</p>
<p id="p-0119" num="0127">Advantageously, this framework allows the engines <b>1431</b> and browser application <b>1421</b> to disregard the fact that the other component is local, remote, or distributed. Between the proxies, the RTCDP protocols assure real-time exchange of the control parameters. Again, the RTCDP control stream exchanged between the proxies <b>1420</b>, <b>1430</b> may comprise information such as argument data file(s) for the server engines, additional feature transformations, addresses where to send the results (back to browser or to content server), format of result (text, XML or Audio RTP stream), extra tag information and address of browser or server where to push data, identifier for the results, commands to execute, data file: what data file to use and whereto get it from; description of the type of processing to apply, e.g. algorithm string&#x2014;sequence of actions to perform on the input; expected type and format of the results; address where to return the results; exception handling mechanisms; I/O event notifications (e.g. for a distributed multi-modal browser like DOM (document object model) level 2 events); modality specific view updates (e.g. ML pushes to the modality specific viewing browsers in the multi-modal browser case), etc.</p>
<p id="p-0120" num="0128"><figref idref="DRAWINGS">FIG. 14</figref><i>b </i>a diagram illustrates a system/method for implementing a distributed conversational framework using proxy servers according to another aspect of the present invention. The exemplary system <b>1400</b> comprises a client <b>1401</b> and a server <b>1402</b>, each comprising an RTCCP/RTCCtP communication stack <b>1403</b> according to the teachings herein for real-time exchange and control of audio data. The client <b>1401</b> comprises an engine proxy <b>1404</b> and a conversational application <b>1405</b> such as a speech browser. The server <b>1402</b> comprises an application proxy <b>1406</b> and conversational engines <b>1407</b>.</p>
<p id="p-0121" num="0129">For this application, the proxies operate as described above with reference to <figref idref="DRAWINGS">FIG. 14</figref><i>a</i>, but instead of implementing RTCDP to exchange control data, the proxies utilize conventional protocols such as TCP/IP and sockets or RMI, RPC or HTTP, for example, for control and exchange of the conversational application API/messages/control, wherein the RTCCP and RTCCtP protocols are used for real-time exchange of the audio via the communication stacks <b>1403</b>.</p>
<p id="p-0122" num="0130">Indeed, in alternate embodiments of the invention, RTCDP control of, e.g., remote conversational engines can be implemented via remote APIs (e.g., RMI (preferably JSAPI (java speech API with extensions) or RPC) to the engines which precedes argument audio streams, although higher level control is still preferably performed via RTCCtP. The remote calls preferably use TCP (over IP) or any other transport mechanism that reliably guarantees message delivery.</p>
<p id="p-0123" num="0131">The overall conversational protocol architecture (or umbrella stack) according to a preferred embodiment of the present invention is illustrated by the diagram of <figref idref="DRAWINGS">FIG. 15</figref>. As illustrated, an extension of H.245 control protocol, i.e., H.245.RTCCP, is implemented on top of UDP/IP or TCP/IP. In addition, the control protocol RTCDP, which is an extension of RTCCtP/RTCP, is implemented on top of UDP/IP or TCP/IP. Likewise, a preferred streaming protocol, RTCCP, which is generated by wrapping a preferred CODEC file format, RECOVC.xxx, in RTP, is implemented on top of UDP/IP or TCP/IP. Moreover, remote APIs such as JSAPI are preferably implemented on top of TCP/IP. It is to be understood that over IP, an explicit switch from UDP transport to TCP transport is preferably supported by the conversational protocol stack.</p>
<p id="p-0124" num="0132">Advantageously, the use of RTP-based conversational protocols as described herein guarantees that the conversational protocols are compatible with, and can be extended to, any network (existing or future) that supports streamed data and Voice over IP or packet voice communications. For example, well-known protocols such as H.323 and SIP (session initiation protocol), which rely on RTP/RTCP can be readily extended to implement the conversational protocols described herein. Moreover, other types of wireless networks can use similar designs adapted to the peculiarity of the underlying communication protocol layers.</p>
<p id="p-0125" num="0133">Further, as indicated above, it is to be understood that the above-described functions could be directly supported on top of TCP, HTTP or other transport protocols, depending on the important of real-time versus guaranteed packet delivery, using the same conversational protocols and header extensions.</p>
<p id="p-0126" num="0134">Referring now to <figref idref="DRAWINGS">FIG. 16</figref>, a diagram illustrates a system/method for implementing RTSP (real time streaming protocol) with conversational protocols according to an embodiment of the present invention. In this embodiment, RTCDP messages are preferably wrapped in RTSP (real time streaming protocol) instead of RTCP, to produce what is referred to herein as RTSCDP (real time streaming conversational distributed protocol). This streaming mechanism is preferred when control of conversational engines is performed by another entity other than the source(s) of the audio RTCCP stream.</p>
<p id="p-0127" num="0135">More specifically, in <figref idref="DRAWINGS">FIG. 16</figref>, a system <b>1600</b> comprises a source <b>1601</b> (e.g., a client hand held device which provides speech I/O to a user), a controller <b>1603</b> (e.g., an application such as a speech browser) and a server <b>1602</b> comprising one or more conversational engines that process the speech I/O, all of which are remotely connected over a network. The source <b>1601</b> and server <b>1602</b> communicate via RTCCP/RTCCtP. The source <b>1601</b> and controller <b>1603</b> communicate via any suitable application protocol. The controller <b>1603</b> and server <b>1602</b> communicate via RTSCDP.</p>
<p id="p-0128" num="0136">Preferably, the RTSCDP protocol is used when control of the conversational engines <b>1602</b> is performed by the controller <b>1603</b> and not the source <b>1601</b>. In such a case, it is preferable to ship the audio from the source <b>1601</b> directly to the server <b>1602</b> engines, instead of shipping audio from the source <b>1601</b> to the controller <b>1603</b> (browser), and then having the controller <b>1603</b> ship the audio and control data to the server engines <b>1602</b>.</p>
<p id="p-0129" num="0137">If the audio is not shipped from the controller <b>1603</b>, it does not utilize the RTCCtP layer. But in a Voice over IP environment, for example, the RTSP protocol has been explicitly developed to act as a remote control of an appliance/service (i.e., controller <b>1602</b>) acting on a RTP stream with appropriate synchronization features with the RTP stream when needed. Therefore, given the current VoIP framework, it is advantageous to extend RTSP to add the conversational control messages (transmitted between the controller <b>1603</b> and server <b>1602</b>) on top of RTSP to control the conversational engines that act on the RTCCP/RTCCtP stream received by the source <b>1601</b>.</p>
<p id="h-0008" num="0000">IV. Distributed Conversational Networking Examples</p>
<p id="p-0130" num="0138">Referring now to <figref idref="DRAWINGS">FIG. 17</figref>, a diagram illustrates an exemplary distributed conversational network that may be implemented using the conversational protocols described herein. In particular, a system <b>1700</b> of <figref idref="DRAWINGS">FIG. 17</figref> illustrates a distributed architecture comprising a conversational (speech) browser. A detailed discussion of the architecture and operation of the speech browser is disclosed, for example, in International Appl. No. PCT/US99/23008, filed on Oct. 1, 1999, entitled &#x201c;Conversational Browser and Conversational Systems&#x201d;, which is commonly assigned, and fully incorporated herein by reference (which also claims priority from the above-incorporated U.S. patent application Ser. Nos. 60/102,957 and 60/117,595). The conversational (speech) browser operates to parse the declarative framework (including the imperative specification) of a VoiceXML page (or any other form of SpeechML (speech markup language)) and render the conversational UI of the target content or transaction to a user. VoiceXML is a speechML that has been recently designed and proposed as a standard for declaratively describing the conversational UI for, e.g., speech browsers and IVR platforms. Example implementations and details of VoiceXML can be found at the VoiceXML home page (www.voicexml.org). The VoiceXML standard is an embodiment of the speech markup language described in the above-incorporated application International Appl. No. PCT/US99/23008.</p>
<p id="p-0131" num="0139">Conventional implementations of speech browsers assume local processing of speech. This is true for browsers that are local on pervasive clients or remote on servers (e.g. telephony servers). It is to be appreciated, however, that the speech recognition engine (and other conversational engines) can be remotely located from the client device, machine, or platform that captures the speech. Indeed, within the Voice XML 0.9 specifications, this can be artificially implemented through a grammar specification.</p>
<p id="p-0132" num="0140">By way of example, as illustrated in <figref idref="DRAWINGS">FIG. 17</figref>, the distributed conversational system <b>1700</b> comprises a local client <b>1701</b>, a browser server <b>1702</b>, an application server <b>1703</b> and an engine server <b>1701</b>, all of which are distributed over a network and communicate using the conversational protocols described herein. A speech browser <b>1705</b> is located on the browser server <b>1704</b> which is accessed by the client <b>1701</b>. As explained below, the browser server <b>1702</b> can act as an intermediary between the client <b>1701</b> and the presentation server <b>1702</b> and/or engine server <b>1704</b>. The browser <b>1705</b> receives pages of VoiceXML from the application (presentation) server <b>1703</b> and processes such pages to render the conversational UI of the pages or transactions.</p>
<p id="p-0133" num="0141">The client device <b>1701</b> may be, for example, a desktop PC (personal computer), a PDA (personal digital assistant), an automobile computer, a smart phone or a conventional telephone. The client <b>1701</b> may also comprise one or more speech-enabled local applications <b>1706</b> (and a database <b>1707</b>) running on the client <b>1701</b>. The client utilizes using conversational protocols described herein to communicate with the speech browser <b>1705</b>. For example, the local application may be a car navigation application in which a &#x201c;Speech Navigation Application&#x201d; interacts with computer mapping software and a GPS (Global Positioning System) device to provide conversational driving directions. In addition, the local application may be a local speech browser, wherein the functions between the local speech browser and speech browser <b>1705</b> are distributed. In addition, functions between a local speech engine and remote speech engine may be distributed.</p>
<p id="p-0134" num="0142">The browser server <b>1702</b> can access any one of a plurality of server systems S<b>1</b>, S<b>2</b>, and S<b>3</b> over network (e.g., the Internet) using a standard network protocol (e.g., HTTP, TCP/IP) to access VoiceXML pages on behalf of the client device <b>1701</b>/local application <b>1706</b> and parse and process the page/transaction via the speech browser <b>1705</b>. For example, the speech browser <b>1705</b> can connect to server S<b>1</b> to access existing HTML information via a transcoding proxy that transcodes, e.g., legacy HTML documents to Q VoiceXML documents. In addition, the speech browser <b>1705</b> can connect to a specialized web server application (S<b>2</b>) such as Lotus Domino server to access Notes data (e.g., Notes e-mail) via a CGI application. In particular, the Domino server can be configured to generate VoiceXML pages and transmit pages using HTTP. In another example, the speech browser <b>1705</b> can connect to a web server application (S<b>3</b>), using a CGI application or Java Servlet to access an legacy database of an enterprise, wherein the web application generates and transmits the information in VoiceXML.</p>
<p id="p-0135" num="0143">In the exemplary distributed system of <figref idref="DRAWINGS">FIG. 17</figref>, it is to be appreciated that the conversational protocols described herein may be implemented for communication between the client <b>1701</b> and the browser server <b>1702</b> and/or the client <b>1701</b> and the engine server <b>1704</b> and/or the browser server <b>1702</b> and the engine server <b>1004</b>. For instance, the real-time conversational coding protocols described herein (e.g., RTCCP) may be used to ship captured audio from the client <b>1701</b> directly to the (1) speech browser <b>1705</b> of the browser server <b>1702</b> (which can the determine where to ship the speech for processing), (2) the speech server <b>1708</b> of the engine server <b>1704</b> for processing by the remote speech recognition engine <b>1709</b>, and/or (3) the speech recognition engine <b>1711</b> (via, e.g., Java Speech API <b>1710</b>). It is to be understood that the transmission of the speech may be performed via conventional analog transmission of telephony speech or analog or digital transmission of speech coded with a conventional CODEC (e.g. GSM, G.711, etc).</p>
<p id="p-0136" num="0144">It is to be appreciated that the system of <figref idref="DRAWINGS">FIG. 17</figref> enables a hybrid client/server architecture, wherein encoded speech data (e.g., RTCCP stream) is transmitted from the audio subsystem of the client <b>1701</b> to the speech browser <b>1702</b> and the speech browser <b>1705</b> determines whether to perform local or server-side processing. More specifically, based on the application logic loaded in the speech browser <b>1705</b>, or based on meta-information within a VoiceXML page/application downloaded from the application server <b>1703</b> specifying where to ship the speech (received from the client <b>1701</b>) for processing, the encoded speech data may be processed locally (via, e.g., the local speech recognition engine <b>1711</b> of the browser server <b>1702</b> or the remote speech recognition engine <b>1709</b> of the engine server <b>1704</b>). In this manner, the application developer specifies this through the XML pages that declaratively describes the application. For example, assuming a VoiceXML page requires processing of the speech by the engine server <b>1704</b>, the speech browser <b>1705</b> can communicate with the speech server <b>1708</b> using the conversational distributed protocols described herein (or via HTTP or sockets or RMI) to ship the audio to the speech server and send the appropriate data file instructions and engine calls.</p>
<p id="p-0137" num="0145">Indeed, rather than redirecting the RTCCP sent from the client <b>1701</b>, it is advantageous to send the RTCCP stream to the browser <b>1705</b> which redirects or multi-casts the RTCCP stream appropriately (this is different from the method described above with reference to <figref idref="DRAWINGS">FIG. 14</figref>, wherein the source transmits the RTCCP stream to the engine server instead of the controller (browser), and RTSCDP is used for communication between the browser and engines). As noted above, the shift between local speech processing (via the browser server <b>1702</b>) and server-side speech processing (via the engine server <b>1704</b>) can be determined by the VoiceXML page from the application server <b>400</b>. Furthermore, this determination can be coded by the content provider or the adaptation to the device, e.g., the browser server <b>1702</b> may determine that its local resources are insufficient for processing the speech and then ships the speech for remote processing via a known or designated server.</p>
<p id="p-0138" num="0146">Alternatively, the conversational protocols described herein (e.g., RTCCtP/RTCDP) provide a mechanism whereby the speech browser <b>1705</b> can communicate with the client <b>1701</b> to advise the client <b>1701</b> where to direct the RTCCP stream for remote processing. For instance, as shown in <figref idref="DRAWINGS">FIG. 17</figref>, the audio can be shipped from the client <b>1701</b> directly to the engines of the browser server <b>1702</b> or the engines of the engine server <b>1704</b>.</p>
<p id="p-0139" num="0147"><figref idref="DRAWINGS">FIG. 18</figref> is a diagram that illustrates another exemplary distributed architecture that may be implemented using the conversational protocols described herein. In particular, the conversational system <b>1800</b> of <figref idref="DRAWINGS">FIG. 18</figref> illustrates a distributed architecture comprising a conversational (multi-modal) browser and CML (conversational markup language). A detailed discussion of the architecture and operation of the multi-modal browser, as well as various CML formats, are disclosed, for example, in U.S. Ser. No. 09/507,526, filed on Feb. 18, 2000, entitled &#x201c;Systems and Methods for Synchronizing Multi-Modal Interactions&#x201d; and U.S. Ser. No. 09/544,823, filed on Apr. 6, 2000, entitled &#x201c;Methods and Systems For Multi-Modal Browsing and Implementation of A Conversational Markup Language,&#x201d; both of which are commonly assigned and fully incorporated herein by reference.</p>
<p id="p-0140" num="0148">In general, as described in the above-incorporated applications, a multi-modal browser comprises a multi-modal shell that parses and interprets CML (multi-modal) documents and mediates among, and coordinates synchronized information exchange between, multiple modality specific browser components (e.g., a visual browser and a speech browser). In one embodiment, content pages and applications are implemented in a gesture-based single authoring CML format, wherein conversational gestures are elementary dialog components that characterize the dialog interaction with the user and provide abstract representation of the dialog independently of the characteristics and UI offered by the device or application rendering the presentation material. The multi-modal browser processes a gesture-based CML document using specific predefined rules to automatically transcode the gesture-based CML document to any supported presentation modality or modalities of the particular browser or device (e.g., transcoded to the appropriate declarative language such as HTML, XHTML, or XML (for automated business-to-business exchanges), WML for wireless portals and VoiceXML for speech applications and IVR systems, etc.), as well as provide tight synchronization between the different views supported by the multi-modal browser.</p>
<p id="p-0141" num="0149">In another embodiment, CML may be implemented by incorporating a plurality of visual and aural markup languages (i.e., a CML document that comprises sub-documents from different interaction modalities). For example, a CML document may be implemented by embedding markup elements from each of a plurality of represented/supported modalities (e.g., VoiceXML and HTML tags) in the same file using synchronizing tags to synchronize the different ML content (i.e., to synchronize an action of a given command in one modality with corresponding actions in the other supported modalities) on an element-by-element basis using, for example, the techniques described in the above-incorporated application International Appl. No. PCT/US99/23008, as well as U.S. Ser. No. 09/507,526.</p>
<p id="p-0142" num="0150">In <figref idref="DRAWINGS">FIG. 18</figref>, the exemplary distributed system <b>1800</b> comprises server <b>1805</b> comprising a multi-modal browser (which comprises a multi-modal shell <b>1801</b>, a registration table <b>1804</b> and multi-modal shell API <b>1803</b>), a client device <b>1807</b> (which comprises a visual browser <b>1808</b> and an audio subsystem <b>1809</b>), a server <b>1810</b> comprising a speech browser <b>1811</b>, a plurality of remote conversational engines <b>1812</b> and a content server <b>1806</b> having content that is authored in CML. In the exemplary system <b>1800</b>, the mono-mode browsers <b>1808</b>, <b>1811</b> execute devices/servers that are remotely located from the server <b>1805</b> comprising the multi-modal browser. The multi-modal shell <b>1801</b> functions as a virtual main browser which processes CML documents retrieved over the network from content server <b>1806</b>. The multi-modal shell <b>1801</b> coordinates information exchange via API <b>1803</b> calls that allow each mono-mode browser application <b>1808</b>, <b>1811</b> to register its active commands and corresponding actions (both inter and intra mode processes as well as actions on other processes). Such registration may include any relevant arguments to perform the appropriate task(s) associated with such commands. The registration table <b>43</b> of the multi-modal shell <b>42</b> is a registry that is implemented as an &#x201c;n-way&#x201d; command/event-to-action registration table, wherein each registered command or event in the table indicates a particular action that results in each of the &#x201c;n&#x201d; modalities that are synchronized and shared for the active application. The multi-modal shell <b>1801</b> parses a retrieved CML document to build the synchronization via the registration table <b>1804</b> send the relevant modality specific information (e.g., markup language) comprising the CML document to each browser for rendering based on its interaction modality.</p>
<p id="p-0143" num="0151">As shown in <figref idref="DRAWINGS">FIG. 18</figref>, the client <b>1808</b> (which comprises the GUI rendering browser <b>1808</b>), the multi-modal browser <b>1801</b>, the speech rendering browser <b>1811</b>, the conversational engines <b>1812</b> and the content/application servers are distributed over a network. Using the conversational protocols described herein, speech data that is captured and encoded at the client <b>1807</b> via the audio subsystem <b>1809</b> can be shipped (via RTCCP) directly to the speech browser <b>1811</b> of server <b>1810</b> or the conversational engines <b>1812</b> for remote processing, or sent to the multi-modal shell <b>1801</b> which then redirects the stream. Moreover, the I/O events of the visual browser <b>1808</b> and speech browser <b>811</b> and synchronization exchanges can be shipped between the mono-modal browsers <b>1808</b>, <b>1811</b> and the multi-modal shell <b>1801</b> using RTCDP, for example. Indeed, the non-streamed events (e.g., GUI events) and information to control the stream are preferably sent via the reliable layer (i.e. RTCDP). The control information (via RTCDP) describes how to process the I/O event (e.g., what data files to use, what processing to perform, whereto send the results, what format of the results, etc.). For instance, using the conversational control protocols described herein, the appropriate conversational engine can process the data according to the specified algorithm (e.g., speech recognition using grammar xxxx, followed by natural language understanding using engine yyy and data files zzzz) and ship the results (as specified by RTCDP) to the address (as specified by RTCDP). If the results are audio (e.g., synthesizes speech from a TTS (text-to-speech) engine, etc.), the results are shipped via RTCCP, for example. It is to be appreciated that all the control information may be encoded by the application developer (and completed via default settings by the browser and other components of the architecture such as the audio capture component).</p>
<p id="p-0144" num="0152">It is to be appreciated that conversational protocols described herein (e.g., RTCCP, RTCCtP/RTCDP) may be used to implement low-bandwidth Voice over IP. For instance, using RECOVC described herein, the H.323 protocol stack (which is a standard is known in the art for a set of protocols providing voice, video and data conferencing over packet-based networks) can be readily extended to encompass RECOVC (i.e., H.323.RTCCP) and add conversational networking as a basic Voice over IP feature. Indeed, all other Voice over IP protocols such as H.323 that implement RTP can be extended using the conversational protocols described herein to allow direct two way voice communications between a regular device (e.g., telephone) and a device connected on a low bandwidth network, while also preserving capabilities to offer conversational functions.</p>
<p id="p-0145" num="0153">By way of example, <figref idref="DRAWINGS">FIG. 19</figref> illustrates a conversational distributed system <b>1904</b> which is accessible via a telephone (land line or wireless) or through a computer network <b>1910</b> (e.g., Internet), wherein the distributed conversational system <b>1904</b> comprises conversational browser servers, speech engine servers, and content and data files that are distributed over the network <b>1904</b>. More specifically, as shown in <figref idref="DRAWINGS">FIG. 19</figref>, client devices such as a conventional telephone <b>1901</b> and wireless phone <b>1902</b> can access desired information from a distributed conversational system <b>1904</b> by connecting via a PSTN <b>1903</b> and router <b>1004</b>. In addition, client devices such as a PDA <b>1907</b>, laptop computer <b>1908</b> and personal computer <b>1909</b> can access the distributed conversational system <b>1904</b> via network <b>1910</b>. The distributed system <b>1904</b> and network <b>1910</b> provide conversational network service extensions and features <b>1911</b> including distributed conversational protocols <b>1906</b> (discussed above), audio coding via RECOVC, applications and meta-information (distributed application protocol), discovery, registration, negotiation protocols, server load management to maintain dialog flow, traffic balancing and routing to maintain dialog flow, engine server selection based on task features and capability requirements and conversational argument availability (data files), conversational arguments (distribution: storage), traffic/routing and caching.</p>
<p id="p-0146" num="0154">AS further illustrated in <figref idref="DRAWINGS">FIG. 19</figref>, RTCCP and RTCCtP/RTCDP can be used for a low bit rate two way human to human communication using the RECOVC codec. In particular, Voice over IP may employ the conversational protocols described herein to implement human to human communication between devices <b>1907</b>, <b>1908</b>, or <b>1909</b> and telephone <b>1912</b>, where digital/analog speech data is transmitted over PSTN <b>1903</b> from the telephone <b>1903</b> converted to RTCCP and otherwise processed via servers <b>1913</b> and <b>1914</b>.</p>
<p id="p-0147" num="0155">It is to be understood that when conversational application are widely distributed across a network, mechanism should be employed to mitigate traffic and delay and some quality of service must be guaranteed and accordingly the network must be managed to provide this quality of service. This is implemented with conventional methods, however new consideration must be added to the cost functions to optimize. Indeed, the conversational distributed systems described herein require:
<ul id="ul0005" list-style="none">
    <li id="ul0005-0001" num="0000">
    <ul id="ul0006" list-style="none">
        <li id="ul0006-0001" num="0156">1. Data files (usually large) to be shipped to the appropriate conversational engines;</li>
        <li id="ul0006-0002" num="0157">2. System management of the conversational engines to minimize processing delay;</li>
        <li id="ul0006-0003" num="0158">3. Multiple transfer (e.g. between audio capture and browser and engine, between engine and browser, between browser and content server etc.)</li>
        <li id="ul0006-0004" num="0159">4. Other synchronized data (multi-modal synchronization data, registration information, I/O events etc.).</li>
    </ul>
    </li>
</ul>
</p>
<p id="p-0148" num="0160">This impacts the management (network and server systems) and renders even more acute the problem of intelligent network caching (not only of the content/business logic but also of the data files), storage, traffic routing, etc. Again all this is done using conventional method the novelty of the invention is that the optimization criteria has changed.</p>
<p id="p-0149" num="0161">Although illustrative embodiments have been described herein with reference to the accompanying drawings, it is to be understood that the present system and method is not limited to those precise embodiments, and that various other changes and modifications may be affected therein by one skilled in the art without departing from the scope or spirit of the invention. All such changes and modifications are intended to be included within the scope of the invention as defined by the appended claims.</p>
<?DETDESC description="Detailed Description" end="tail"?>
</description>
<claims id="claims">
<claim id="CLM-00001" num="00001">
<claim-text>1. A communication system, comprising:
<claim-text>a communication stack comprising:
<claim-text>a first layer for generating encoded audio data, wherein the audio data comprises compressed feature vectors representative of speech, wherein the encoded audio data comprises a file format that enables transmission of segments of speech and decompression of the segments of speech in a random order;</claim-text>
<claim-text>a second layer for generating a data stream comprising the encoded audio data;</claim-text>
<claim-text>a third layer for generating a transmission control data stream, wherein the transmission control data stream comprises meta information for coding scheme notifications; and</claim-text>
<claim-text>a fourth layer for transporting the data stream and the transmission control data stream.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00002" num="00002">
<claim-text>2. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first layer is adapted to reconstruct an audio waveform from encoded audio data.</claim-text>
</claim>
<claim id="CLM-00003" num="00003">
<claim-text>3. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the first layer comprises one of a plurality of encoding schemes and the encoded audio data generated by the first layer comprises one of a plurality of corresponding encoding types.</claim-text>
</claim>
<claim id="CLM-00004" num="00004">
<claim-text>4. The system of <claim-ref idref="CLM-00003">claim 3</claim-ref>, wherein the coding schemes comprise (1) a speech recognition enabled coding scheme and (2) a speech reconstruction and speech recognition enabled coding scheme.</claim-text>
</claim>
<claim id="CLM-00005" num="00005">
<claim-text>5. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the meta information for coding scheme notifications comprises meta information for one of selecting, changing, and selecting and changing, the encoding type of the encoded audio data.</claim-text>
</claim>
<claim id="CLM-00006" num="00006">
<claim-text>6. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the communication stack further comprises a fifth layer for generating distributed control data, wherein the distributed control data is implemented for coordinating distributed conversational functions.</claim-text>
</claim>
<claim id="CLM-00007" num="00007">
<claim-text>7. The system of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the distributed control data comprises one of (1) a pointer to a data file (2) a data file, (2) an I/O (input/output) event notification, (3) a specification of a format of an output result, (4) an address specifying where to send an output result, (5) a field identifier for XML tags, (6) field identifiers for an active form, and a combination thereof.</claim-text>
</claim>
<claim id="CLM-00008" num="00008">
<claim-text>8. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the file format of the encoded audio data comprises a file header comprising meta information that specifies a coding scheme, file size, and coding arguments associated with the encoded audio data.</claim-text>
</claim>
<claim id="CLM-00009" num="00009">
<claim-text>9. The system of <claim-ref idref="CLM-00008">claim 8</claim-ref>, wherein the coding arguments comprise one of sampling frequency, feature vector type, feature vector dimension, language type, frame duration, and a combination thereof.</claim-text>
</claim>
<claim id="CLM-00010" num="00010">
<claim-text>10. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the file format comprises a speech segment header followed by a speech segment, wherein the speech segment comprises a plurality of blocks, wherein each block comprises a predefined number of frames of encoded speech data.</claim-text>
</claim>
<claim id="CLM-00011" num="00011">
<claim-text>11. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the file format comprises at least one of a plurality of segment types and corresponding segment headers, wherein a given segment header comprises meta information that specifies a segment type and a length of the segment.</claim-text>
</claim>
<claim id="CLM-00012" num="00012">
<claim-text>12. The system of <claim-ref idref="CLM-00011">claim 11</claim-ref>, wherein the segment types comprise a speech segment, a silence segment, an end-of-stream segment, and ancillary data segments.</claim-text>
</claim>
<claim id="CLM-00013" num="00013">
<claim-text>13. The system of <claim-ref idref="CLM-00012">claim 12</claim-ref>, wherein error recovery information is specified by an ancillary data segment and corresponding data segment header.</claim-text>
</claim>
<claim id="CLM-00014" num="00014">
<claim-text>14. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the second layer employs RTP (real time protocol) to wrap the encoded audio data.</claim-text>
</claim>
<claim id="CLM-00015" num="00015">
<claim-text>15. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the third layer employs RTCP (real time control protocol) to wrap the transmission control data.</claim-text>
</claim>
<claim id="CLM-00016" num="00016">
<claim-text>16. The system of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the fifth layer employs RTCP (real time control protocol) to wrap the distributed control data.</claim-text>
</claim>
<claim id="CLM-00017" num="00017">
<claim-text>17. The system of <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the fifth layer employs RTSP (real time streaming protocol) to wrap the distributed control data.</claim-text>
</claim>
<claim id="CLM-00018" num="00018">
<claim-text>18. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the communication stack further comprises an API layer comprising one of JSAPI (java speech API), RPC (remote procedure call), RMI (remote method invocation) and a combination thereof.</claim-text>
</claim>
<claim id="CLM-00019" num="00019">
<claim-text>19. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the communication stack is implemented in a Voice over IP network.</claim-text>
</claim>
<claim id="CLM-00020" num="00020">
<claim-text>20. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the fourth layer comprises one of UDP (user datagram protocol), TCP (transmission control protocol), and both.</claim-text>
</claim>
<claim id="CLM-00021" num="00021">
<claim-text>21. The system of <claim-ref idref="CLM-00001">claim 1</claim-ref>, wherein the communication stack is tangibly embodied as program instructions on a program storage device.</claim-text>
</claim>
<claim id="CLM-00022" num="00022">
<claim-text>22. A communication system for use in a real-time distributed conversational network, the communication system comprising:
<claim-text>a communication stack comprising:
<claim-text>a first layer for generating encoded audio data;</claim-text>
<claim-text>a second layer for wrapping encoded audio data in a real-time encoded audio data stream;</claim-text>
<claim-text>a third layer for wrapping control messages in a real-time control data stream</claim-text>
</claim-text>
<claim-text>comprising control data that enables real-time control and coordination of</claim-text>
<claim-text>conversational distributed functions over the network; and
<claim-text>a fourth layer for generating a real-time transmission control data stream, wherein the real-time transmission control data stream comprises meta information for providing coding scheme notifications.</claim-text>
</claim-text>
</claim-text>
</claim>
<claim id="CLM-00023" num="00023">
<claim-text>23. The system of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein the communication stack employs RTP (Real Time Protocol).</claim-text>
</claim>
<claim id="CLM-00024" num="00024">
<claim-text>24. The system of <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein meta information associated with the real-time encoded audio stream is added in a header of an RTP packet, wherein the RTP header extension comprises one field indicating an encoding type of the encoded audio data in the RTP packet and a second field comprising header information associated with a file of the encoded audio data.</claim-text>
</claim>
<claim id="CLM-00025" num="00025">
<claim-text>25. The system of <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein meta information associated with the real-time control data stream is added in a header of an RTCP (Real Time Control Protocol) packet, wherein the RTCP header comprises a first field indicating a type of conversational distributed protocol and a second field comprising a corresponding control message.</claim-text>
</claim>
<claim id="CLM-00026" num="00026">
<claim-text>26. The system of <claim-ref idref="CLM-00025">claim 25</claim-ref>, wherein the communication stack is implemented in a distributed multi-modal browser framework, and wherein the real-time control data streams comprises one of browser I/O events, a pointer to an argument data file, a pointer to a remote engine, and a combination thereof.</claim-text>
</claim>
<claim id="CLM-00027" num="00027">
<claim-text>27. The system of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein the communication stack is implemented in a Voice Over IP network.</claim-text>
</claim>
<claim id="CLM-00028" num="00028">
<claim-text>28. The system of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein RTSP (real-time streaming protocol) is employed to wrap the control messages.</claim-text>
</claim>
<claim id="CLM-00029" num="00029">
<claim-text>29. The system of <claim-ref idref="CLM-00022">claim 22</claim-ref>, wherein the communication stack is tangibly embodied as program instructions on a program storage device.</claim-text>
</claim>
<claim id="CLM-00030" num="00030">
<claim-text>30. A method for providing real-time distributed conversational computing, comprising the steps of:
<claim-text>generating encoded audio data;</claim-text>
<claim-text>wrapping encoded audio data in a real-time encoded audio data stream; and</claim-text>
<claim-text>wrapping control messages in a real-time control data stream comprising control data that enables real-time control and coordination of conversational distributed functions over the network,</claim-text>
<claim-text>wherein the audio data comprises compressed feature vectors representative of speech and wherein the encoded audio data comprises a file format that enables transmission of segments of speech and decompression of the segments of speech in a random order.</claim-text>
</claim-text>
</claim>
</claims>
</us-patent-grant>

